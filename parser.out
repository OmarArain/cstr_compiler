Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> external_declaration
Rule 2     program -> program external_declaration
Rule 3     external_declaration -> declaration
Rule 4     external_declaration -> EXTERN declaration
Rule 5     external_declaration -> function_definition
Rule 6     function_definition -> type function_declarator compound_instruction
Rule 7     declaration -> type declarator_list SEMICOLON
Rule 8     type -> INT
Rule 9     type -> STRING
Rule 10    declarator_list -> declarator
Rule 11    declarator_list -> declaration_list COMMA declarator
Rule 12    declaration_list -> declaration
Rule 13    declaration_list -> declaration_list declaration
Rule 14    declarator -> IDENT
Rule 15    declarator -> function_declarator
Rule 16    function_declarator -> IDENT LPARENS RPARENS
Rule 17    function_declarator -> IDENT LPARENS parameter_list RPARENS
Rule 18    parameter_list -> parameter_declaration
Rule 19    parameter_list -> parameter_list COMMA parameter_declaration
Rule 20    parameter_declaration -> type IDENT
Rule 21    instruction -> SEMICOLON
Rule 22    instruction -> compound_instruction
Rule 23    instruction -> expression_instruction
Rule 24    instruction -> iteration_instruction
Rule 25    instruction -> select_instruction
Rule 26    instruction -> jump_instruction
Rule 27    expression_instruction -> expression SEMICOLON
Rule 28    expression_instruction -> assignment SEMICOLON
Rule 29    assignment -> IDENT ASSIGNMENT expression
Rule 30    compound_instruction -> block_start declaration_list instruction_list block_end
Rule 31    compound_instruction -> block_start declaration_list block_end
Rule 32    compound_instruction -> block_start instruction_list block_end
Rule 33    compound_instruction -> block_start block_end
Rule 34    block_start -> LBRACKET
Rule 35    block_end -> RBRACKET
Rule 36    instruction_list -> instruction
Rule 37    instruction_list -> instruction_list instruction
Rule 38    select_instruction -> cond_instruction THEN instruction
Rule 39    select_instruction -> cond_instruction THEN instruction ELSE instruction
Rule 40    cond_instruction -> IF LPARENS condition RPARENS
Rule 41    iteration_instruction -> WHILE LPARENS condition RPARENS instruction
Rule 42    iteration_instruction -> DO instruction WHILE LPARENS condition RPARENS
Rule 43    iteration_instruction -> FOR LPARENS assignment SEMICOLON condition SEMICOLON assignment RPARENS instruction
Rule 44    jump_instruction -> RETURN expression SEMICOLON
Rule 45    condition -> expression comparison_operator expression
Rule 46    comparison_operator -> EQUAL
Rule 47    comparison_operator -> NOTEQUAL
Rule 48    comparison_operator -> LESS
Rule 49    comparison_operator -> GREATER
Rule 50    comparison_operator -> LESSEQUAL
Rule 51    comparison_operator -> GREATEREQUAL
Rule 52    expression -> expression_additive
Rule 53    expression -> SHIFTLEFT expression_additive
Rule 54    expression -> SHIFTRIGHT expression_additive
Rule 55    expression_additive -> expression_multiplicative
Rule 56    expression_additive -> expression_additive ADD expression_multiplicative
Rule 57    expression_additive -> expression_additive SUBTRACT expression_multiplicative
Rule 58    expression_multiplicative -> unary_expression
Rule 59    expression_multiplicative -> expression_multiplicative MULTIPLY unary_expression
Rule 60    expression_multiplicative -> expression_multiplicative DIVIDE unary_expression
Rule 61    expression_multiplicative -> expression_multiplicative MODULO unary_expression
Rule 62    unary_expression -> postfix_expression
Rule 63    unary_expression -> SUBTRACT unary_expression
Rule 64    postfix_expression -> primary_expression
Rule 65    postfix_expression -> IDENT LPARENS argument_expression_list RPARENS
Rule 66    postfix_expression -> IDENT LPARENS RPARENS
Rule 67    argument_expression_list -> expression
Rule 68    argument_expression_list -> argument_expression_list COMMA expression
Rule 69    primary_expression -> IDENT
Rule 70    primary_expression -> CONST_INT
Rule 71    primary_expression -> CONST_STRING
Rule 72    primary_expression -> LPARENS expression RPARENS

Terminals, with rules where they appear

ADD                  : 56
ASSIGNMENT           : 29
COMMA                : 11 19 68
CONST_INT            : 70
CONST_STRING         : 71
DIVIDE               : 60
DO                   : 42
ELSE                 : 39
EQUAL                : 46
EXTERN               : 4
FOR                  : 43
GREATER              : 49
GREATEREQUAL         : 51
IDENT                : 14 16 17 20 29 65 66 69
IF                   : 40
INT                  : 8
LBRACKET             : 34
LESS                 : 48
LESSEQUAL            : 50
LPARENS              : 16 17 40 41 42 43 65 66 72
MODULO               : 61
MULTIPLY             : 59
NOTEQUAL             : 47
RBRACKET             : 35
RETURN               : 44
RPARENS              : 16 17 40 41 42 43 65 66 72
SEMICOLON            : 7 21 27 28 43 43 44
SHIFTLEFT            : 53
SHIFTRIGHT           : 54
STRING               : 9
SUBTRACT             : 57 63
THEN                 : 38 39
WHILE                : 41 42
error                : 

Nonterminals, with rules where they appear

argument_expression_list : 65 68
assignment           : 28 43 43
block_end            : 30 31 32 33
block_start          : 30 31 32 33
comparison_operator  : 45
compound_instruction : 6 22
cond_instruction     : 38 39
condition            : 40 41 42 43
declaration          : 3 4 12 13
declaration_list     : 11 13 30 31
declarator           : 10 11
declarator_list      : 7
expression           : 27 29 44 45 45 67 68 72
expression_additive  : 52 53 54 56 57
expression_instruction : 23
expression_multiplicative : 55 56 57 59 60 61
external_declaration : 1 2
function_declarator  : 6 15
function_definition  : 5
instruction          : 36 37 38 39 39 41 42 43
instruction_list     : 30 32 37
iteration_instruction : 24
jump_instruction     : 26
parameter_declaration : 18 19
parameter_list       : 17 19
postfix_expression   : 62
primary_expression   : 64
program              : 2 0
select_instruction   : 25
type                 : 6 7 20
unary_expression     : 58 59 60 61 63

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . external_declaration
    (2) program -> . program external_declaration
    (3) external_declaration -> . declaration
    (4) external_declaration -> . EXTERN declaration
    (5) external_declaration -> . function_definition
    (7) declaration -> . type declarator_list SEMICOLON
    (6) function_definition -> . type function_declarator compound_instruction
    (8) type -> . INT
    (9) type -> . STRING

    EXTERN          shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 6

    declaration                    shift and go to state 1
    program                        shift and go to state 5
    function_definition            shift and go to state 2
    type                           shift and go to state 8
    external_declaration           shift and go to state 3

state 1

    (3) external_declaration -> declaration .

    EXTERN          reduce using rule 3 (external_declaration -> declaration .)
    INT             reduce using rule 3 (external_declaration -> declaration .)
    STRING          reduce using rule 3 (external_declaration -> declaration .)
    $end            reduce using rule 3 (external_declaration -> declaration .)


state 2

    (5) external_declaration -> function_definition .

    EXTERN          reduce using rule 5 (external_declaration -> function_definition .)
    INT             reduce using rule 5 (external_declaration -> function_definition .)
    STRING          reduce using rule 5 (external_declaration -> function_definition .)
    $end            reduce using rule 5 (external_declaration -> function_definition .)


state 3

    (1) program -> external_declaration .

    EXTERN          reduce using rule 1 (program -> external_declaration .)
    INT             reduce using rule 1 (program -> external_declaration .)
    STRING          reduce using rule 1 (program -> external_declaration .)
    $end            reduce using rule 1 (program -> external_declaration .)


state 4

    (4) external_declaration -> EXTERN . declaration
    (7) declaration -> . type declarator_list SEMICOLON
    (8) type -> . INT
    (9) type -> . STRING

    INT             shift and go to state 7
    STRING          shift and go to state 6

    declaration                    shift and go to state 9
    type                           shift and go to state 10

state 5

    (0) S' -> program .
    (2) program -> program . external_declaration
    (3) external_declaration -> . declaration
    (4) external_declaration -> . EXTERN declaration
    (5) external_declaration -> . function_definition
    (7) declaration -> . type declarator_list SEMICOLON
    (6) function_definition -> . type function_declarator compound_instruction
    (8) type -> . INT
    (9) type -> . STRING

    EXTERN          shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 6

    declaration                    shift and go to state 1
    function_definition            shift and go to state 2
    type                           shift and go to state 8
    external_declaration           shift and go to state 11

state 6

    (9) type -> STRING .

    IDENT           reduce using rule 9 (type -> STRING .)
    INT             reduce using rule 9 (type -> STRING .)
    STRING          reduce using rule 9 (type -> STRING .)


state 7

    (8) type -> INT .

    IDENT           reduce using rule 8 (type -> INT .)
    INT             reduce using rule 8 (type -> INT .)
    STRING          reduce using rule 8 (type -> INT .)


state 8

    (7) declaration -> type . declarator_list SEMICOLON
    (6) function_definition -> type . function_declarator compound_instruction
    (10) declarator_list -> . declarator
    (11) declarator_list -> . declaration_list COMMA declarator
    (16) function_declarator -> . IDENT LPARENS RPARENS
    (17) function_declarator -> . IDENT LPARENS parameter_list RPARENS
    (14) declarator -> . IDENT
    (15) declarator -> . function_declarator
    (12) declaration_list -> . declaration
    (13) declaration_list -> . declaration_list declaration
    (7) declaration -> . type declarator_list SEMICOLON
    (8) type -> . INT
    (9) type -> . STRING

    IDENT           shift and go to state 17
    INT             shift and go to state 7
    STRING          shift and go to state 6

    declaration                    shift and go to state 12
    declaration_list               shift and go to state 16
    declarator_list                shift and go to state 15
    function_declarator            shift and go to state 13
    declarator                     shift and go to state 14
    type                           shift and go to state 10

state 9

    (4) external_declaration -> EXTERN declaration .

    EXTERN          reduce using rule 4 (external_declaration -> EXTERN declaration .)
    INT             reduce using rule 4 (external_declaration -> EXTERN declaration .)
    STRING          reduce using rule 4 (external_declaration -> EXTERN declaration .)
    $end            reduce using rule 4 (external_declaration -> EXTERN declaration .)


state 10

    (7) declaration -> type . declarator_list SEMICOLON
    (10) declarator_list -> . declarator
    (11) declarator_list -> . declaration_list COMMA declarator
    (14) declarator -> . IDENT
    (15) declarator -> . function_declarator
    (12) declaration_list -> . declaration
    (13) declaration_list -> . declaration_list declaration
    (16) function_declarator -> . IDENT LPARENS RPARENS
    (17) function_declarator -> . IDENT LPARENS parameter_list RPARENS
    (7) declaration -> . type declarator_list SEMICOLON
    (8) type -> . INT
    (9) type -> . STRING

    IDENT           shift and go to state 19
    INT             shift and go to state 7
    STRING          shift and go to state 6

    declaration                    shift and go to state 12
    declarator_list                shift and go to state 15
    declaration_list               shift and go to state 16
    function_declarator            shift and go to state 18
    declarator                     shift and go to state 14
    type                           shift and go to state 10

state 11

    (2) program -> program external_declaration .

    EXTERN          reduce using rule 2 (program -> program external_declaration .)
    INT             reduce using rule 2 (program -> program external_declaration .)
    STRING          reduce using rule 2 (program -> program external_declaration .)
    $end            reduce using rule 2 (program -> program external_declaration .)


state 12

    (12) declaration_list -> declaration .

    COMMA           reduce using rule 12 (declaration_list -> declaration .)
    INT             reduce using rule 12 (declaration_list -> declaration .)
    STRING          reduce using rule 12 (declaration_list -> declaration .)
    RBRACKET        reduce using rule 12 (declaration_list -> declaration .)
    SEMICOLON       reduce using rule 12 (declaration_list -> declaration .)
    WHILE           reduce using rule 12 (declaration_list -> declaration .)
    DO              reduce using rule 12 (declaration_list -> declaration .)
    FOR             reduce using rule 12 (declaration_list -> declaration .)
    RETURN          reduce using rule 12 (declaration_list -> declaration .)
    LBRACKET        reduce using rule 12 (declaration_list -> declaration .)
    SHIFTLEFT       reduce using rule 12 (declaration_list -> declaration .)
    SHIFTRIGHT      reduce using rule 12 (declaration_list -> declaration .)
    IDENT           reduce using rule 12 (declaration_list -> declaration .)
    IF              reduce using rule 12 (declaration_list -> declaration .)
    SUBTRACT        reduce using rule 12 (declaration_list -> declaration .)
    CONST_INT       reduce using rule 12 (declaration_list -> declaration .)
    CONST_STRING    reduce using rule 12 (declaration_list -> declaration .)
    LPARENS         reduce using rule 12 (declaration_list -> declaration .)


state 13

    (6) function_definition -> type function_declarator . compound_instruction
    (15) declarator -> function_declarator .
    (30) compound_instruction -> . block_start declaration_list instruction_list block_end
    (31) compound_instruction -> . block_start declaration_list block_end
    (32) compound_instruction -> . block_start instruction_list block_end
    (33) compound_instruction -> . block_start block_end
    (34) block_start -> . LBRACKET

    SEMICOLON       reduce using rule 15 (declarator -> function_declarator .)
    LBRACKET        shift and go to state 22

    block_start                    shift and go to state 20
    compound_instruction           shift and go to state 21

state 14

    (10) declarator_list -> declarator .

    SEMICOLON       reduce using rule 10 (declarator_list -> declarator .)


state 15

    (7) declaration -> type declarator_list . SEMICOLON

    SEMICOLON       shift and go to state 23


state 16

    (11) declarator_list -> declaration_list . COMMA declarator
    (13) declaration_list -> declaration_list . declaration
    (7) declaration -> . type declarator_list SEMICOLON
    (8) type -> . INT
    (9) type -> . STRING

    COMMA           shift and go to state 24
    INT             shift and go to state 7
    STRING          shift and go to state 6

    declaration                    shift and go to state 25
    type                           shift and go to state 10

state 17

    (16) function_declarator -> IDENT . LPARENS RPARENS
    (17) function_declarator -> IDENT . LPARENS parameter_list RPARENS
    (14) declarator -> IDENT .

    LPARENS         shift and go to state 26
    SEMICOLON       reduce using rule 14 (declarator -> IDENT .)


state 18

    (15) declarator -> function_declarator .

    SEMICOLON       reduce using rule 15 (declarator -> function_declarator .)


state 19

    (14) declarator -> IDENT .
    (16) function_declarator -> IDENT . LPARENS RPARENS
    (17) function_declarator -> IDENT . LPARENS parameter_list RPARENS

    SEMICOLON       reduce using rule 14 (declarator -> IDENT .)
    LPARENS         shift and go to state 26


state 20

    (30) compound_instruction -> block_start . declaration_list instruction_list block_end
    (31) compound_instruction -> block_start . declaration_list block_end
    (32) compound_instruction -> block_start . instruction_list block_end
    (33) compound_instruction -> block_start . block_end
    (12) declaration_list -> . declaration
    (13) declaration_list -> . declaration_list declaration
    (36) instruction_list -> . instruction
    (37) instruction_list -> . instruction_list instruction
    (35) block_end -> . RBRACKET
    (7) declaration -> . type declarator_list SEMICOLON
    (21) instruction -> . SEMICOLON
    (22) instruction -> . compound_instruction
    (23) instruction -> . expression_instruction
    (24) instruction -> . iteration_instruction
    (25) instruction -> . select_instruction
    (26) instruction -> . jump_instruction
    (8) type -> . INT
    (9) type -> . STRING
    (30) compound_instruction -> . block_start declaration_list instruction_list block_end
    (31) compound_instruction -> . block_start declaration_list block_end
    (32) compound_instruction -> . block_start instruction_list block_end
    (33) compound_instruction -> . block_start block_end
    (27) expression_instruction -> . expression SEMICOLON
    (28) expression_instruction -> . assignment SEMICOLON
    (41) iteration_instruction -> . WHILE LPARENS condition RPARENS instruction
    (42) iteration_instruction -> . DO instruction WHILE LPARENS condition RPARENS
    (43) iteration_instruction -> . FOR LPARENS assignment SEMICOLON condition SEMICOLON assignment RPARENS instruction
    (38) select_instruction -> . cond_instruction THEN instruction
    (39) select_instruction -> . cond_instruction THEN instruction ELSE instruction
    (44) jump_instruction -> . RETURN expression SEMICOLON
    (34) block_start -> . LBRACKET
    (52) expression -> . expression_additive
    (53) expression -> . SHIFTLEFT expression_additive
    (54) expression -> . SHIFTRIGHT expression_additive
    (29) assignment -> . IDENT ASSIGNMENT expression
    (40) cond_instruction -> . IF LPARENS condition RPARENS
    (55) expression_additive -> . expression_multiplicative
    (56) expression_additive -> . expression_additive ADD expression_multiplicative
    (57) expression_additive -> . expression_additive SUBTRACT expression_multiplicative
    (58) expression_multiplicative -> . unary_expression
    (59) expression_multiplicative -> . expression_multiplicative MULTIPLY unary_expression
    (60) expression_multiplicative -> . expression_multiplicative DIVIDE unary_expression
    (61) expression_multiplicative -> . expression_multiplicative MODULO unary_expression
    (62) unary_expression -> . postfix_expression
    (63) unary_expression -> . SUBTRACT unary_expression
    (64) postfix_expression -> . primary_expression
    (65) postfix_expression -> . IDENT LPARENS argument_expression_list RPARENS
    (66) postfix_expression -> . IDENT LPARENS RPARENS
    (69) primary_expression -> . IDENT
    (70) primary_expression -> . CONST_INT
    (71) primary_expression -> . CONST_STRING
    (72) primary_expression -> . LPARENS expression RPARENS

    RBRACKET        shift and go to state 30
    SEMICOLON       shift and go to state 29
    INT             shift and go to state 7
    STRING          shift and go to state 6
    WHILE           shift and go to state 54
    DO              shift and go to state 38
    FOR             shift and go to state 56
    RETURN          shift and go to state 51
    LBRACKET        shift and go to state 22
    SHIFTLEFT       shift and go to state 40
    SHIFTRIGHT      shift and go to state 36
    IDENT           shift and go to state 49
    IF              shift and go to state 45
    SUBTRACT        shift and go to state 33
    CONST_INT       shift and go to state 43
    CONST_STRING    shift and go to state 28
    LPARENS         shift and go to state 47

    expression_instruction         shift and go to state 42
    select_instruction             shift and go to state 27
    compound_instruction           shift and go to state 44
    expression                     shift and go to state 31
    expression_multiplicative      shift and go to state 46
    postfix_expression             shift and go to state 48
    assignment                     shift and go to state 32
    type                           shift and go to state 10
    block_start                    shift and go to state 20
    declaration                    shift and go to state 12
    primary_expression             shift and go to state 34
    unary_expression               shift and go to state 50
    cond_instruction               shift and go to state 35
    expression_additive            shift and go to state 52
    iteration_instruction          shift and go to state 53
    jump_instruction               shift and go to state 37
    block_end                      shift and go to state 55
    declaration_list               shift and go to state 57
    instruction                    shift and go to state 39
    instruction_list               shift and go to state 41

state 21

    (6) function_definition -> type function_declarator compound_instruction .

    EXTERN          reduce using rule 6 (function_definition -> type function_declarator compound_instruction .)
    INT             reduce using rule 6 (function_definition -> type function_declarator compound_instruction .)
    STRING          reduce using rule 6 (function_definition -> type function_declarator compound_instruction .)
    $end            reduce using rule 6 (function_definition -> type function_declarator compound_instruction .)


state 22

    (34) block_start -> LBRACKET .

    RBRACKET        reduce using rule 34 (block_start -> LBRACKET .)
    SEMICOLON       reduce using rule 34 (block_start -> LBRACKET .)
    INT             reduce using rule 34 (block_start -> LBRACKET .)
    STRING          reduce using rule 34 (block_start -> LBRACKET .)
    WHILE           reduce using rule 34 (block_start -> LBRACKET .)
    DO              reduce using rule 34 (block_start -> LBRACKET .)
    FOR             reduce using rule 34 (block_start -> LBRACKET .)
    RETURN          reduce using rule 34 (block_start -> LBRACKET .)
    LBRACKET        reduce using rule 34 (block_start -> LBRACKET .)
    SHIFTLEFT       reduce using rule 34 (block_start -> LBRACKET .)
    SHIFTRIGHT      reduce using rule 34 (block_start -> LBRACKET .)
    IDENT           reduce using rule 34 (block_start -> LBRACKET .)
    IF              reduce using rule 34 (block_start -> LBRACKET .)
    SUBTRACT        reduce using rule 34 (block_start -> LBRACKET .)
    CONST_INT       reduce using rule 34 (block_start -> LBRACKET .)
    CONST_STRING    reduce using rule 34 (block_start -> LBRACKET .)
    LPARENS         reduce using rule 34 (block_start -> LBRACKET .)


state 23

    (7) declaration -> type declarator_list SEMICOLON .

    RBRACKET        reduce using rule 7 (declaration -> type declarator_list SEMICOLON .)
    SEMICOLON       reduce using rule 7 (declaration -> type declarator_list SEMICOLON .)
    INT             reduce using rule 7 (declaration -> type declarator_list SEMICOLON .)
    STRING          reduce using rule 7 (declaration -> type declarator_list SEMICOLON .)
    WHILE           reduce using rule 7 (declaration -> type declarator_list SEMICOLON .)
    DO              reduce using rule 7 (declaration -> type declarator_list SEMICOLON .)
    FOR             reduce using rule 7 (declaration -> type declarator_list SEMICOLON .)
    RETURN          reduce using rule 7 (declaration -> type declarator_list SEMICOLON .)
    LBRACKET        reduce using rule 7 (declaration -> type declarator_list SEMICOLON .)
    SHIFTLEFT       reduce using rule 7 (declaration -> type declarator_list SEMICOLON .)
    SHIFTRIGHT      reduce using rule 7 (declaration -> type declarator_list SEMICOLON .)
    IDENT           reduce using rule 7 (declaration -> type declarator_list SEMICOLON .)
    IF              reduce using rule 7 (declaration -> type declarator_list SEMICOLON .)
    SUBTRACT        reduce using rule 7 (declaration -> type declarator_list SEMICOLON .)
    CONST_INT       reduce using rule 7 (declaration -> type declarator_list SEMICOLON .)
    CONST_STRING    reduce using rule 7 (declaration -> type declarator_list SEMICOLON .)
    LPARENS         reduce using rule 7 (declaration -> type declarator_list SEMICOLON .)
    COMMA           reduce using rule 7 (declaration -> type declarator_list SEMICOLON .)
    EXTERN          reduce using rule 7 (declaration -> type declarator_list SEMICOLON .)
    $end            reduce using rule 7 (declaration -> type declarator_list SEMICOLON .)


state 24

    (11) declarator_list -> declaration_list COMMA . declarator
    (14) declarator -> . IDENT
    (15) declarator -> . function_declarator
    (16) function_declarator -> . IDENT LPARENS RPARENS
    (17) function_declarator -> . IDENT LPARENS parameter_list RPARENS

    IDENT           shift and go to state 19

    function_declarator            shift and go to state 18
    declarator                     shift and go to state 58

state 25

    (13) declaration_list -> declaration_list declaration .

    COMMA           reduce using rule 13 (declaration_list -> declaration_list declaration .)
    INT             reduce using rule 13 (declaration_list -> declaration_list declaration .)
    STRING          reduce using rule 13 (declaration_list -> declaration_list declaration .)
    RBRACKET        reduce using rule 13 (declaration_list -> declaration_list declaration .)
    SEMICOLON       reduce using rule 13 (declaration_list -> declaration_list declaration .)
    WHILE           reduce using rule 13 (declaration_list -> declaration_list declaration .)
    DO              reduce using rule 13 (declaration_list -> declaration_list declaration .)
    FOR             reduce using rule 13 (declaration_list -> declaration_list declaration .)
    RETURN          reduce using rule 13 (declaration_list -> declaration_list declaration .)
    LBRACKET        reduce using rule 13 (declaration_list -> declaration_list declaration .)
    SHIFTLEFT       reduce using rule 13 (declaration_list -> declaration_list declaration .)
    SHIFTRIGHT      reduce using rule 13 (declaration_list -> declaration_list declaration .)
    IDENT           reduce using rule 13 (declaration_list -> declaration_list declaration .)
    IF              reduce using rule 13 (declaration_list -> declaration_list declaration .)
    SUBTRACT        reduce using rule 13 (declaration_list -> declaration_list declaration .)
    CONST_INT       reduce using rule 13 (declaration_list -> declaration_list declaration .)
    CONST_STRING    reduce using rule 13 (declaration_list -> declaration_list declaration .)
    LPARENS         reduce using rule 13 (declaration_list -> declaration_list declaration .)


state 26

    (16) function_declarator -> IDENT LPARENS . RPARENS
    (17) function_declarator -> IDENT LPARENS . parameter_list RPARENS
    (18) parameter_list -> . parameter_declaration
    (19) parameter_list -> . parameter_list COMMA parameter_declaration
    (20) parameter_declaration -> . type IDENT
    (8) type -> . INT
    (9) type -> . STRING

    RPARENS         shift and go to state 60
    INT             shift and go to state 7
    STRING          shift and go to state 6

    parameter_list                 shift and go to state 61
    type                           shift and go to state 62
    parameter_declaration          shift and go to state 59

state 27

    (25) instruction -> select_instruction .

    WHILE           reduce using rule 25 (instruction -> select_instruction .)
    RBRACKET        reduce using rule 25 (instruction -> select_instruction .)
    SEMICOLON       reduce using rule 25 (instruction -> select_instruction .)
    DO              reduce using rule 25 (instruction -> select_instruction .)
    FOR             reduce using rule 25 (instruction -> select_instruction .)
    RETURN          reduce using rule 25 (instruction -> select_instruction .)
    LBRACKET        reduce using rule 25 (instruction -> select_instruction .)
    SHIFTLEFT       reduce using rule 25 (instruction -> select_instruction .)
    SHIFTRIGHT      reduce using rule 25 (instruction -> select_instruction .)
    IDENT           reduce using rule 25 (instruction -> select_instruction .)
    IF              reduce using rule 25 (instruction -> select_instruction .)
    SUBTRACT        reduce using rule 25 (instruction -> select_instruction .)
    CONST_INT       reduce using rule 25 (instruction -> select_instruction .)
    CONST_STRING    reduce using rule 25 (instruction -> select_instruction .)
    LPARENS         reduce using rule 25 (instruction -> select_instruction .)
    ELSE            reduce using rule 25 (instruction -> select_instruction .)


state 28

    (71) primary_expression -> CONST_STRING .

    MULTIPLY        reduce using rule 71 (primary_expression -> CONST_STRING .)
    DIVIDE          reduce using rule 71 (primary_expression -> CONST_STRING .)
    MODULO          reduce using rule 71 (primary_expression -> CONST_STRING .)
    ADD             reduce using rule 71 (primary_expression -> CONST_STRING .)
    SUBTRACT        reduce using rule 71 (primary_expression -> CONST_STRING .)
    RPARENS         reduce using rule 71 (primary_expression -> CONST_STRING .)
    SEMICOLON       reduce using rule 71 (primary_expression -> CONST_STRING .)
    COMMA           reduce using rule 71 (primary_expression -> CONST_STRING .)
    EQUAL           reduce using rule 71 (primary_expression -> CONST_STRING .)
    NOTEQUAL        reduce using rule 71 (primary_expression -> CONST_STRING .)
    LESS            reduce using rule 71 (primary_expression -> CONST_STRING .)
    GREATER         reduce using rule 71 (primary_expression -> CONST_STRING .)
    LESSEQUAL       reduce using rule 71 (primary_expression -> CONST_STRING .)
    GREATEREQUAL    reduce using rule 71 (primary_expression -> CONST_STRING .)


state 29

    (21) instruction -> SEMICOLON .

    WHILE           reduce using rule 21 (instruction -> SEMICOLON .)
    RBRACKET        reduce using rule 21 (instruction -> SEMICOLON .)
    SEMICOLON       reduce using rule 21 (instruction -> SEMICOLON .)
    DO              reduce using rule 21 (instruction -> SEMICOLON .)
    FOR             reduce using rule 21 (instruction -> SEMICOLON .)
    RETURN          reduce using rule 21 (instruction -> SEMICOLON .)
    LBRACKET        reduce using rule 21 (instruction -> SEMICOLON .)
    SHIFTLEFT       reduce using rule 21 (instruction -> SEMICOLON .)
    SHIFTRIGHT      reduce using rule 21 (instruction -> SEMICOLON .)
    IDENT           reduce using rule 21 (instruction -> SEMICOLON .)
    IF              reduce using rule 21 (instruction -> SEMICOLON .)
    SUBTRACT        reduce using rule 21 (instruction -> SEMICOLON .)
    CONST_INT       reduce using rule 21 (instruction -> SEMICOLON .)
    CONST_STRING    reduce using rule 21 (instruction -> SEMICOLON .)
    LPARENS         reduce using rule 21 (instruction -> SEMICOLON .)
    ELSE            reduce using rule 21 (instruction -> SEMICOLON .)


state 30

    (35) block_end -> RBRACKET .

    EXTERN          reduce using rule 35 (block_end -> RBRACKET .)
    INT             reduce using rule 35 (block_end -> RBRACKET .)
    STRING          reduce using rule 35 (block_end -> RBRACKET .)
    $end            reduce using rule 35 (block_end -> RBRACKET .)
    RBRACKET        reduce using rule 35 (block_end -> RBRACKET .)
    SEMICOLON       reduce using rule 35 (block_end -> RBRACKET .)
    WHILE           reduce using rule 35 (block_end -> RBRACKET .)
    DO              reduce using rule 35 (block_end -> RBRACKET .)
    FOR             reduce using rule 35 (block_end -> RBRACKET .)
    RETURN          reduce using rule 35 (block_end -> RBRACKET .)
    LBRACKET        reduce using rule 35 (block_end -> RBRACKET .)
    SHIFTLEFT       reduce using rule 35 (block_end -> RBRACKET .)
    SHIFTRIGHT      reduce using rule 35 (block_end -> RBRACKET .)
    IDENT           reduce using rule 35 (block_end -> RBRACKET .)
    IF              reduce using rule 35 (block_end -> RBRACKET .)
    SUBTRACT        reduce using rule 35 (block_end -> RBRACKET .)
    CONST_INT       reduce using rule 35 (block_end -> RBRACKET .)
    CONST_STRING    reduce using rule 35 (block_end -> RBRACKET .)
    LPARENS         reduce using rule 35 (block_end -> RBRACKET .)
    ELSE            reduce using rule 35 (block_end -> RBRACKET .)


state 31

    (27) expression_instruction -> expression . SEMICOLON

    SEMICOLON       shift and go to state 63


state 32

    (28) expression_instruction -> assignment . SEMICOLON

    SEMICOLON       shift and go to state 64


state 33

    (63) unary_expression -> SUBTRACT . unary_expression
    (62) unary_expression -> . postfix_expression
    (63) unary_expression -> . SUBTRACT unary_expression
    (64) postfix_expression -> . primary_expression
    (65) postfix_expression -> . IDENT LPARENS argument_expression_list RPARENS
    (66) postfix_expression -> . IDENT LPARENS RPARENS
    (69) primary_expression -> . IDENT
    (70) primary_expression -> . CONST_INT
    (71) primary_expression -> . CONST_STRING
    (72) primary_expression -> . LPARENS expression RPARENS

    SUBTRACT        shift and go to state 33
    IDENT           shift and go to state 66
    CONST_INT       shift and go to state 43
    CONST_STRING    shift and go to state 28
    LPARENS         shift and go to state 47

    primary_expression             shift and go to state 34
    unary_expression               shift and go to state 65
    postfix_expression             shift and go to state 48

state 34

    (64) postfix_expression -> primary_expression .

    MULTIPLY        reduce using rule 64 (postfix_expression -> primary_expression .)
    DIVIDE          reduce using rule 64 (postfix_expression -> primary_expression .)
    MODULO          reduce using rule 64 (postfix_expression -> primary_expression .)
    ADD             reduce using rule 64 (postfix_expression -> primary_expression .)
    SUBTRACT        reduce using rule 64 (postfix_expression -> primary_expression .)
    RPARENS         reduce using rule 64 (postfix_expression -> primary_expression .)
    SEMICOLON       reduce using rule 64 (postfix_expression -> primary_expression .)
    EQUAL           reduce using rule 64 (postfix_expression -> primary_expression .)
    NOTEQUAL        reduce using rule 64 (postfix_expression -> primary_expression .)
    LESS            reduce using rule 64 (postfix_expression -> primary_expression .)
    GREATER         reduce using rule 64 (postfix_expression -> primary_expression .)
    LESSEQUAL       reduce using rule 64 (postfix_expression -> primary_expression .)
    GREATEREQUAL    reduce using rule 64 (postfix_expression -> primary_expression .)
    COMMA           reduce using rule 64 (postfix_expression -> primary_expression .)


state 35

    (38) select_instruction -> cond_instruction . THEN instruction
    (39) select_instruction -> cond_instruction . THEN instruction ELSE instruction

    THEN            shift and go to state 67


state 36

    (54) expression -> SHIFTRIGHT . expression_additive
    (55) expression_additive -> . expression_multiplicative
    (56) expression_additive -> . expression_additive ADD expression_multiplicative
    (57) expression_additive -> . expression_additive SUBTRACT expression_multiplicative
    (58) expression_multiplicative -> . unary_expression
    (59) expression_multiplicative -> . expression_multiplicative MULTIPLY unary_expression
    (60) expression_multiplicative -> . expression_multiplicative DIVIDE unary_expression
    (61) expression_multiplicative -> . expression_multiplicative MODULO unary_expression
    (62) unary_expression -> . postfix_expression
    (63) unary_expression -> . SUBTRACT unary_expression
    (64) postfix_expression -> . primary_expression
    (65) postfix_expression -> . IDENT LPARENS argument_expression_list RPARENS
    (66) postfix_expression -> . IDENT LPARENS RPARENS
    (69) primary_expression -> . IDENT
    (70) primary_expression -> . CONST_INT
    (71) primary_expression -> . CONST_STRING
    (72) primary_expression -> . LPARENS expression RPARENS

    SUBTRACT        shift and go to state 33
    IDENT           shift and go to state 66
    CONST_INT       shift and go to state 43
    CONST_STRING    shift and go to state 28
    LPARENS         shift and go to state 47

    expression_multiplicative      shift and go to state 46
    expression_additive            shift and go to state 68
    unary_expression               shift and go to state 50
    primary_expression             shift and go to state 34
    postfix_expression             shift and go to state 48

state 37

    (26) instruction -> jump_instruction .

    WHILE           reduce using rule 26 (instruction -> jump_instruction .)
    RBRACKET        reduce using rule 26 (instruction -> jump_instruction .)
    SEMICOLON       reduce using rule 26 (instruction -> jump_instruction .)
    DO              reduce using rule 26 (instruction -> jump_instruction .)
    FOR             reduce using rule 26 (instruction -> jump_instruction .)
    RETURN          reduce using rule 26 (instruction -> jump_instruction .)
    LBRACKET        reduce using rule 26 (instruction -> jump_instruction .)
    SHIFTLEFT       reduce using rule 26 (instruction -> jump_instruction .)
    SHIFTRIGHT      reduce using rule 26 (instruction -> jump_instruction .)
    IDENT           reduce using rule 26 (instruction -> jump_instruction .)
    IF              reduce using rule 26 (instruction -> jump_instruction .)
    SUBTRACT        reduce using rule 26 (instruction -> jump_instruction .)
    CONST_INT       reduce using rule 26 (instruction -> jump_instruction .)
    CONST_STRING    reduce using rule 26 (instruction -> jump_instruction .)
    LPARENS         reduce using rule 26 (instruction -> jump_instruction .)
    ELSE            reduce using rule 26 (instruction -> jump_instruction .)


state 38

    (42) iteration_instruction -> DO . instruction WHILE LPARENS condition RPARENS
    (21) instruction -> . SEMICOLON
    (22) instruction -> . compound_instruction
    (23) instruction -> . expression_instruction
    (24) instruction -> . iteration_instruction
    (25) instruction -> . select_instruction
    (26) instruction -> . jump_instruction
    (30) compound_instruction -> . block_start declaration_list instruction_list block_end
    (31) compound_instruction -> . block_start declaration_list block_end
    (32) compound_instruction -> . block_start instruction_list block_end
    (33) compound_instruction -> . block_start block_end
    (27) expression_instruction -> . expression SEMICOLON
    (28) expression_instruction -> . assignment SEMICOLON
    (41) iteration_instruction -> . WHILE LPARENS condition RPARENS instruction
    (42) iteration_instruction -> . DO instruction WHILE LPARENS condition RPARENS
    (43) iteration_instruction -> . FOR LPARENS assignment SEMICOLON condition SEMICOLON assignment RPARENS instruction
    (38) select_instruction -> . cond_instruction THEN instruction
    (39) select_instruction -> . cond_instruction THEN instruction ELSE instruction
    (44) jump_instruction -> . RETURN expression SEMICOLON
    (34) block_start -> . LBRACKET
    (52) expression -> . expression_additive
    (53) expression -> . SHIFTLEFT expression_additive
    (54) expression -> . SHIFTRIGHT expression_additive
    (29) assignment -> . IDENT ASSIGNMENT expression
    (40) cond_instruction -> . IF LPARENS condition RPARENS
    (55) expression_additive -> . expression_multiplicative
    (56) expression_additive -> . expression_additive ADD expression_multiplicative
    (57) expression_additive -> . expression_additive SUBTRACT expression_multiplicative
    (58) expression_multiplicative -> . unary_expression
    (59) expression_multiplicative -> . expression_multiplicative MULTIPLY unary_expression
    (60) expression_multiplicative -> . expression_multiplicative DIVIDE unary_expression
    (61) expression_multiplicative -> . expression_multiplicative MODULO unary_expression
    (62) unary_expression -> . postfix_expression
    (63) unary_expression -> . SUBTRACT unary_expression
    (64) postfix_expression -> . primary_expression
    (65) postfix_expression -> . IDENT LPARENS argument_expression_list RPARENS
    (66) postfix_expression -> . IDENT LPARENS RPARENS
    (69) primary_expression -> . IDENT
    (70) primary_expression -> . CONST_INT
    (71) primary_expression -> . CONST_STRING
    (72) primary_expression -> . LPARENS expression RPARENS

    SEMICOLON       shift and go to state 29
    WHILE           shift and go to state 54
    DO              shift and go to state 38
    FOR             shift and go to state 56
    RETURN          shift and go to state 51
    LBRACKET        shift and go to state 22
    SHIFTLEFT       shift and go to state 40
    SHIFTRIGHT      shift and go to state 36
    IDENT           shift and go to state 49
    IF              shift and go to state 45
    SUBTRACT        shift and go to state 33
    CONST_INT       shift and go to state 43
    CONST_STRING    shift and go to state 28
    LPARENS         shift and go to state 47

    unary_expression               shift and go to state 50
    expression_instruction         shift and go to state 42
    block_start                    shift and go to state 20
    cond_instruction               shift and go to state 35
    primary_expression             shift and go to state 34
    compound_instruction           shift and go to state 44
    select_instruction             shift and go to state 27
    iteration_instruction          shift and go to state 53
    expression                     shift and go to state 31
    expression_multiplicative      shift and go to state 46
    jump_instruction               shift and go to state 37
    expression_additive            shift and go to state 52
    postfix_expression             shift and go to state 48
    instruction                    shift and go to state 69
    assignment                     shift and go to state 32

state 39

    (36) instruction_list -> instruction .

    RBRACKET        reduce using rule 36 (instruction_list -> instruction .)
    SEMICOLON       reduce using rule 36 (instruction_list -> instruction .)
    WHILE           reduce using rule 36 (instruction_list -> instruction .)
    DO              reduce using rule 36 (instruction_list -> instruction .)
    FOR             reduce using rule 36 (instruction_list -> instruction .)
    RETURN          reduce using rule 36 (instruction_list -> instruction .)
    LBRACKET        reduce using rule 36 (instruction_list -> instruction .)
    SHIFTLEFT       reduce using rule 36 (instruction_list -> instruction .)
    SHIFTRIGHT      reduce using rule 36 (instruction_list -> instruction .)
    IDENT           reduce using rule 36 (instruction_list -> instruction .)
    IF              reduce using rule 36 (instruction_list -> instruction .)
    SUBTRACT        reduce using rule 36 (instruction_list -> instruction .)
    CONST_INT       reduce using rule 36 (instruction_list -> instruction .)
    CONST_STRING    reduce using rule 36 (instruction_list -> instruction .)
    LPARENS         reduce using rule 36 (instruction_list -> instruction .)


state 40

    (53) expression -> SHIFTLEFT . expression_additive
    (55) expression_additive -> . expression_multiplicative
    (56) expression_additive -> . expression_additive ADD expression_multiplicative
    (57) expression_additive -> . expression_additive SUBTRACT expression_multiplicative
    (58) expression_multiplicative -> . unary_expression
    (59) expression_multiplicative -> . expression_multiplicative MULTIPLY unary_expression
    (60) expression_multiplicative -> . expression_multiplicative DIVIDE unary_expression
    (61) expression_multiplicative -> . expression_multiplicative MODULO unary_expression
    (62) unary_expression -> . postfix_expression
    (63) unary_expression -> . SUBTRACT unary_expression
    (64) postfix_expression -> . primary_expression
    (65) postfix_expression -> . IDENT LPARENS argument_expression_list RPARENS
    (66) postfix_expression -> . IDENT LPARENS RPARENS
    (69) primary_expression -> . IDENT
    (70) primary_expression -> . CONST_INT
    (71) primary_expression -> . CONST_STRING
    (72) primary_expression -> . LPARENS expression RPARENS

    SUBTRACT        shift and go to state 33
    IDENT           shift and go to state 66
    CONST_INT       shift and go to state 43
    CONST_STRING    shift and go to state 28
    LPARENS         shift and go to state 47

    expression_multiplicative      shift and go to state 46
    expression_additive            shift and go to state 70
    unary_expression               shift and go to state 50
    primary_expression             shift and go to state 34
    postfix_expression             shift and go to state 48

state 41

    (32) compound_instruction -> block_start instruction_list . block_end
    (37) instruction_list -> instruction_list . instruction
    (35) block_end -> . RBRACKET
    (21) instruction -> . SEMICOLON
    (22) instruction -> . compound_instruction
    (23) instruction -> . expression_instruction
    (24) instruction -> . iteration_instruction
    (25) instruction -> . select_instruction
    (26) instruction -> . jump_instruction
    (30) compound_instruction -> . block_start declaration_list instruction_list block_end
    (31) compound_instruction -> . block_start declaration_list block_end
    (32) compound_instruction -> . block_start instruction_list block_end
    (33) compound_instruction -> . block_start block_end
    (27) expression_instruction -> . expression SEMICOLON
    (28) expression_instruction -> . assignment SEMICOLON
    (41) iteration_instruction -> . WHILE LPARENS condition RPARENS instruction
    (42) iteration_instruction -> . DO instruction WHILE LPARENS condition RPARENS
    (43) iteration_instruction -> . FOR LPARENS assignment SEMICOLON condition SEMICOLON assignment RPARENS instruction
    (38) select_instruction -> . cond_instruction THEN instruction
    (39) select_instruction -> . cond_instruction THEN instruction ELSE instruction
    (44) jump_instruction -> . RETURN expression SEMICOLON
    (34) block_start -> . LBRACKET
    (52) expression -> . expression_additive
    (53) expression -> . SHIFTLEFT expression_additive
    (54) expression -> . SHIFTRIGHT expression_additive
    (29) assignment -> . IDENT ASSIGNMENT expression
    (40) cond_instruction -> . IF LPARENS condition RPARENS
    (55) expression_additive -> . expression_multiplicative
    (56) expression_additive -> . expression_additive ADD expression_multiplicative
    (57) expression_additive -> . expression_additive SUBTRACT expression_multiplicative
    (58) expression_multiplicative -> . unary_expression
    (59) expression_multiplicative -> . expression_multiplicative MULTIPLY unary_expression
    (60) expression_multiplicative -> . expression_multiplicative DIVIDE unary_expression
    (61) expression_multiplicative -> . expression_multiplicative MODULO unary_expression
    (62) unary_expression -> . postfix_expression
    (63) unary_expression -> . SUBTRACT unary_expression
    (64) postfix_expression -> . primary_expression
    (65) postfix_expression -> . IDENT LPARENS argument_expression_list RPARENS
    (66) postfix_expression -> . IDENT LPARENS RPARENS
    (69) primary_expression -> . IDENT
    (70) primary_expression -> . CONST_INT
    (71) primary_expression -> . CONST_STRING
    (72) primary_expression -> . LPARENS expression RPARENS

    RBRACKET        shift and go to state 30
    SEMICOLON       shift and go to state 29
    WHILE           shift and go to state 54
    DO              shift and go to state 38
    FOR             shift and go to state 56
    RETURN          shift and go to state 51
    LBRACKET        shift and go to state 22
    SHIFTLEFT       shift and go to state 40
    SHIFTRIGHT      shift and go to state 36
    IDENT           shift and go to state 49
    IF              shift and go to state 45
    SUBTRACT        shift and go to state 33
    CONST_INT       shift and go to state 43
    CONST_STRING    shift and go to state 28
    LPARENS         shift and go to state 47

    unary_expression               shift and go to state 50
    expression_instruction         shift and go to state 42
    block_start                    shift and go to state 20
    cond_instruction               shift and go to state 35
    select_instruction             shift and go to state 27
    primary_expression             shift and go to state 34
    compound_instruction           shift and go to state 44
    iteration_instruction          shift and go to state 53
    expression                     shift and go to state 31
    expression_multiplicative      shift and go to state 46
    jump_instruction               shift and go to state 37
    expression_additive            shift and go to state 52
    block_end                      shift and go to state 71
    postfix_expression             shift and go to state 48
    instruction                    shift and go to state 72
    assignment                     shift and go to state 32

state 42

    (23) instruction -> expression_instruction .

    WHILE           reduce using rule 23 (instruction -> expression_instruction .)
    RBRACKET        reduce using rule 23 (instruction -> expression_instruction .)
    SEMICOLON       reduce using rule 23 (instruction -> expression_instruction .)
    DO              reduce using rule 23 (instruction -> expression_instruction .)
    FOR             reduce using rule 23 (instruction -> expression_instruction .)
    RETURN          reduce using rule 23 (instruction -> expression_instruction .)
    LBRACKET        reduce using rule 23 (instruction -> expression_instruction .)
    SHIFTLEFT       reduce using rule 23 (instruction -> expression_instruction .)
    SHIFTRIGHT      reduce using rule 23 (instruction -> expression_instruction .)
    IDENT           reduce using rule 23 (instruction -> expression_instruction .)
    IF              reduce using rule 23 (instruction -> expression_instruction .)
    SUBTRACT        reduce using rule 23 (instruction -> expression_instruction .)
    CONST_INT       reduce using rule 23 (instruction -> expression_instruction .)
    CONST_STRING    reduce using rule 23 (instruction -> expression_instruction .)
    LPARENS         reduce using rule 23 (instruction -> expression_instruction .)
    ELSE            reduce using rule 23 (instruction -> expression_instruction .)


state 43

    (70) primary_expression -> CONST_INT .

    MULTIPLY        reduce using rule 70 (primary_expression -> CONST_INT .)
    DIVIDE          reduce using rule 70 (primary_expression -> CONST_INT .)
    MODULO          reduce using rule 70 (primary_expression -> CONST_INT .)
    ADD             reduce using rule 70 (primary_expression -> CONST_INT .)
    SUBTRACT        reduce using rule 70 (primary_expression -> CONST_INT .)
    RPARENS         reduce using rule 70 (primary_expression -> CONST_INT .)
    SEMICOLON       reduce using rule 70 (primary_expression -> CONST_INT .)
    COMMA           reduce using rule 70 (primary_expression -> CONST_INT .)
    EQUAL           reduce using rule 70 (primary_expression -> CONST_INT .)
    NOTEQUAL        reduce using rule 70 (primary_expression -> CONST_INT .)
    LESS            reduce using rule 70 (primary_expression -> CONST_INT .)
    GREATER         reduce using rule 70 (primary_expression -> CONST_INT .)
    LESSEQUAL       reduce using rule 70 (primary_expression -> CONST_INT .)
    GREATEREQUAL    reduce using rule 70 (primary_expression -> CONST_INT .)


state 44

    (22) instruction -> compound_instruction .

    WHILE           reduce using rule 22 (instruction -> compound_instruction .)
    RBRACKET        reduce using rule 22 (instruction -> compound_instruction .)
    SEMICOLON       reduce using rule 22 (instruction -> compound_instruction .)
    DO              reduce using rule 22 (instruction -> compound_instruction .)
    FOR             reduce using rule 22 (instruction -> compound_instruction .)
    RETURN          reduce using rule 22 (instruction -> compound_instruction .)
    LBRACKET        reduce using rule 22 (instruction -> compound_instruction .)
    SHIFTLEFT       reduce using rule 22 (instruction -> compound_instruction .)
    SHIFTRIGHT      reduce using rule 22 (instruction -> compound_instruction .)
    IDENT           reduce using rule 22 (instruction -> compound_instruction .)
    IF              reduce using rule 22 (instruction -> compound_instruction .)
    SUBTRACT        reduce using rule 22 (instruction -> compound_instruction .)
    CONST_INT       reduce using rule 22 (instruction -> compound_instruction .)
    CONST_STRING    reduce using rule 22 (instruction -> compound_instruction .)
    LPARENS         reduce using rule 22 (instruction -> compound_instruction .)
    ELSE            reduce using rule 22 (instruction -> compound_instruction .)


state 45

    (40) cond_instruction -> IF . LPARENS condition RPARENS

    LPARENS         shift and go to state 73


state 46

    (55) expression_additive -> expression_multiplicative .
    (59) expression_multiplicative -> expression_multiplicative . MULTIPLY unary_expression
    (60) expression_multiplicative -> expression_multiplicative . DIVIDE unary_expression
    (61) expression_multiplicative -> expression_multiplicative . MODULO unary_expression

    ADD             reduce using rule 55 (expression_additive -> expression_multiplicative .)
    SUBTRACT        reduce using rule 55 (expression_additive -> expression_multiplicative .)
    EQUAL           reduce using rule 55 (expression_additive -> expression_multiplicative .)
    NOTEQUAL        reduce using rule 55 (expression_additive -> expression_multiplicative .)
    LESS            reduce using rule 55 (expression_additive -> expression_multiplicative .)
    GREATER         reduce using rule 55 (expression_additive -> expression_multiplicative .)
    LESSEQUAL       reduce using rule 55 (expression_additive -> expression_multiplicative .)
    GREATEREQUAL    reduce using rule 55 (expression_additive -> expression_multiplicative .)
    SEMICOLON       reduce using rule 55 (expression_additive -> expression_multiplicative .)
    RPARENS         reduce using rule 55 (expression_additive -> expression_multiplicative .)
    COMMA           reduce using rule 55 (expression_additive -> expression_multiplicative .)
    MULTIPLY        shift and go to state 75
    DIVIDE          shift and go to state 76
    MODULO          shift and go to state 74


state 47

    (72) primary_expression -> LPARENS . expression RPARENS
    (52) expression -> . expression_additive
    (53) expression -> . SHIFTLEFT expression_additive
    (54) expression -> . SHIFTRIGHT expression_additive
    (55) expression_additive -> . expression_multiplicative
    (56) expression_additive -> . expression_additive ADD expression_multiplicative
    (57) expression_additive -> . expression_additive SUBTRACT expression_multiplicative
    (58) expression_multiplicative -> . unary_expression
    (59) expression_multiplicative -> . expression_multiplicative MULTIPLY unary_expression
    (60) expression_multiplicative -> . expression_multiplicative DIVIDE unary_expression
    (61) expression_multiplicative -> . expression_multiplicative MODULO unary_expression
    (62) unary_expression -> . postfix_expression
    (63) unary_expression -> . SUBTRACT unary_expression
    (64) postfix_expression -> . primary_expression
    (65) postfix_expression -> . IDENT LPARENS argument_expression_list RPARENS
    (66) postfix_expression -> . IDENT LPARENS RPARENS
    (69) primary_expression -> . IDENT
    (70) primary_expression -> . CONST_INT
    (71) primary_expression -> . CONST_STRING
    (72) primary_expression -> . LPARENS expression RPARENS

    SHIFTLEFT       shift and go to state 40
    SHIFTRIGHT      shift and go to state 36
    SUBTRACT        shift and go to state 33
    IDENT           shift and go to state 66
    CONST_INT       shift and go to state 43
    CONST_STRING    shift and go to state 28
    LPARENS         shift and go to state 47

    expression_multiplicative      shift and go to state 46
    primary_expression             shift and go to state 34
    unary_expression               shift and go to state 50
    expression_additive            shift and go to state 52
    postfix_expression             shift and go to state 48
    expression                     shift and go to state 77

state 48

    (62) unary_expression -> postfix_expression .

    MULTIPLY        reduce using rule 62 (unary_expression -> postfix_expression .)
    DIVIDE          reduce using rule 62 (unary_expression -> postfix_expression .)
    MODULO          reduce using rule 62 (unary_expression -> postfix_expression .)
    ADD             reduce using rule 62 (unary_expression -> postfix_expression .)
    SUBTRACT        reduce using rule 62 (unary_expression -> postfix_expression .)
    SEMICOLON       reduce using rule 62 (unary_expression -> postfix_expression .)
    RPARENS         reduce using rule 62 (unary_expression -> postfix_expression .)
    EQUAL           reduce using rule 62 (unary_expression -> postfix_expression .)
    NOTEQUAL        reduce using rule 62 (unary_expression -> postfix_expression .)
    LESS            reduce using rule 62 (unary_expression -> postfix_expression .)
    GREATER         reduce using rule 62 (unary_expression -> postfix_expression .)
    LESSEQUAL       reduce using rule 62 (unary_expression -> postfix_expression .)
    GREATEREQUAL    reduce using rule 62 (unary_expression -> postfix_expression .)
    COMMA           reduce using rule 62 (unary_expression -> postfix_expression .)


state 49

    (29) assignment -> IDENT . ASSIGNMENT expression
    (65) postfix_expression -> IDENT . LPARENS argument_expression_list RPARENS
    (66) postfix_expression -> IDENT . LPARENS RPARENS
    (69) primary_expression -> IDENT .

    ASSIGNMENT      shift and go to state 79
    LPARENS         shift and go to state 78
    MULTIPLY        reduce using rule 69 (primary_expression -> IDENT .)
    DIVIDE          reduce using rule 69 (primary_expression -> IDENT .)
    MODULO          reduce using rule 69 (primary_expression -> IDENT .)
    ADD             reduce using rule 69 (primary_expression -> IDENT .)
    SUBTRACT        reduce using rule 69 (primary_expression -> IDENT .)
    SEMICOLON       reduce using rule 69 (primary_expression -> IDENT .)


state 50

    (58) expression_multiplicative -> unary_expression .

    MULTIPLY        reduce using rule 58 (expression_multiplicative -> unary_expression .)
    DIVIDE          reduce using rule 58 (expression_multiplicative -> unary_expression .)
    MODULO          reduce using rule 58 (expression_multiplicative -> unary_expression .)
    ADD             reduce using rule 58 (expression_multiplicative -> unary_expression .)
    SUBTRACT        reduce using rule 58 (expression_multiplicative -> unary_expression .)
    SEMICOLON       reduce using rule 58 (expression_multiplicative -> unary_expression .)
    EQUAL           reduce using rule 58 (expression_multiplicative -> unary_expression .)
    NOTEQUAL        reduce using rule 58 (expression_multiplicative -> unary_expression .)
    LESS            reduce using rule 58 (expression_multiplicative -> unary_expression .)
    GREATER         reduce using rule 58 (expression_multiplicative -> unary_expression .)
    LESSEQUAL       reduce using rule 58 (expression_multiplicative -> unary_expression .)
    GREATEREQUAL    reduce using rule 58 (expression_multiplicative -> unary_expression .)
    RPARENS         reduce using rule 58 (expression_multiplicative -> unary_expression .)
    COMMA           reduce using rule 58 (expression_multiplicative -> unary_expression .)


state 51

    (44) jump_instruction -> RETURN . expression SEMICOLON
    (52) expression -> . expression_additive
    (53) expression -> . SHIFTLEFT expression_additive
    (54) expression -> . SHIFTRIGHT expression_additive
    (55) expression_additive -> . expression_multiplicative
    (56) expression_additive -> . expression_additive ADD expression_multiplicative
    (57) expression_additive -> . expression_additive SUBTRACT expression_multiplicative
    (58) expression_multiplicative -> . unary_expression
    (59) expression_multiplicative -> . expression_multiplicative MULTIPLY unary_expression
    (60) expression_multiplicative -> . expression_multiplicative DIVIDE unary_expression
    (61) expression_multiplicative -> . expression_multiplicative MODULO unary_expression
    (62) unary_expression -> . postfix_expression
    (63) unary_expression -> . SUBTRACT unary_expression
    (64) postfix_expression -> . primary_expression
    (65) postfix_expression -> . IDENT LPARENS argument_expression_list RPARENS
    (66) postfix_expression -> . IDENT LPARENS RPARENS
    (69) primary_expression -> . IDENT
    (70) primary_expression -> . CONST_INT
    (71) primary_expression -> . CONST_STRING
    (72) primary_expression -> . LPARENS expression RPARENS

    SHIFTLEFT       shift and go to state 40
    SHIFTRIGHT      shift and go to state 36
    SUBTRACT        shift and go to state 33
    IDENT           shift and go to state 66
    CONST_INT       shift and go to state 43
    CONST_STRING    shift and go to state 28
    LPARENS         shift and go to state 47

    expression_multiplicative      shift and go to state 46
    primary_expression             shift and go to state 34
    unary_expression               shift and go to state 50
    expression_additive            shift and go to state 52
    postfix_expression             shift and go to state 48
    expression                     shift and go to state 80

state 52

    (52) expression -> expression_additive .
    (56) expression_additive -> expression_additive . ADD expression_multiplicative
    (57) expression_additive -> expression_additive . SUBTRACT expression_multiplicative

    SEMICOLON       reduce using rule 52 (expression -> expression_additive .)
    RPARENS         reduce using rule 52 (expression -> expression_additive .)
    EQUAL           reduce using rule 52 (expression -> expression_additive .)
    NOTEQUAL        reduce using rule 52 (expression -> expression_additive .)
    LESS            reduce using rule 52 (expression -> expression_additive .)
    GREATER         reduce using rule 52 (expression -> expression_additive .)
    LESSEQUAL       reduce using rule 52 (expression -> expression_additive .)
    GREATEREQUAL    reduce using rule 52 (expression -> expression_additive .)
    COMMA           reduce using rule 52 (expression -> expression_additive .)
    ADD             shift and go to state 81
    SUBTRACT        shift and go to state 82


state 53

    (24) instruction -> iteration_instruction .

    WHILE           reduce using rule 24 (instruction -> iteration_instruction .)
    RBRACKET        reduce using rule 24 (instruction -> iteration_instruction .)
    SEMICOLON       reduce using rule 24 (instruction -> iteration_instruction .)
    DO              reduce using rule 24 (instruction -> iteration_instruction .)
    FOR             reduce using rule 24 (instruction -> iteration_instruction .)
    RETURN          reduce using rule 24 (instruction -> iteration_instruction .)
    LBRACKET        reduce using rule 24 (instruction -> iteration_instruction .)
    SHIFTLEFT       reduce using rule 24 (instruction -> iteration_instruction .)
    SHIFTRIGHT      reduce using rule 24 (instruction -> iteration_instruction .)
    IDENT           reduce using rule 24 (instruction -> iteration_instruction .)
    IF              reduce using rule 24 (instruction -> iteration_instruction .)
    SUBTRACT        reduce using rule 24 (instruction -> iteration_instruction .)
    CONST_INT       reduce using rule 24 (instruction -> iteration_instruction .)
    CONST_STRING    reduce using rule 24 (instruction -> iteration_instruction .)
    LPARENS         reduce using rule 24 (instruction -> iteration_instruction .)
    ELSE            reduce using rule 24 (instruction -> iteration_instruction .)


state 54

    (41) iteration_instruction -> WHILE . LPARENS condition RPARENS instruction

    LPARENS         shift and go to state 83


state 55

    (33) compound_instruction -> block_start block_end .

    EXTERN          reduce using rule 33 (compound_instruction -> block_start block_end .)
    INT             reduce using rule 33 (compound_instruction -> block_start block_end .)
    STRING          reduce using rule 33 (compound_instruction -> block_start block_end .)
    $end            reduce using rule 33 (compound_instruction -> block_start block_end .)
    ELSE            reduce using rule 33 (compound_instruction -> block_start block_end .)
    RBRACKET        reduce using rule 33 (compound_instruction -> block_start block_end .)
    SEMICOLON       reduce using rule 33 (compound_instruction -> block_start block_end .)
    WHILE           reduce using rule 33 (compound_instruction -> block_start block_end .)
    DO              reduce using rule 33 (compound_instruction -> block_start block_end .)
    FOR             reduce using rule 33 (compound_instruction -> block_start block_end .)
    RETURN          reduce using rule 33 (compound_instruction -> block_start block_end .)
    LBRACKET        reduce using rule 33 (compound_instruction -> block_start block_end .)
    SHIFTLEFT       reduce using rule 33 (compound_instruction -> block_start block_end .)
    SHIFTRIGHT      reduce using rule 33 (compound_instruction -> block_start block_end .)
    IDENT           reduce using rule 33 (compound_instruction -> block_start block_end .)
    IF              reduce using rule 33 (compound_instruction -> block_start block_end .)
    SUBTRACT        reduce using rule 33 (compound_instruction -> block_start block_end .)
    CONST_INT       reduce using rule 33 (compound_instruction -> block_start block_end .)
    CONST_STRING    reduce using rule 33 (compound_instruction -> block_start block_end .)
    LPARENS         reduce using rule 33 (compound_instruction -> block_start block_end .)


state 56

    (43) iteration_instruction -> FOR . LPARENS assignment SEMICOLON condition SEMICOLON assignment RPARENS instruction

    LPARENS         shift and go to state 84


state 57

    (30) compound_instruction -> block_start declaration_list . instruction_list block_end
    (31) compound_instruction -> block_start declaration_list . block_end
    (13) declaration_list -> declaration_list . declaration
    (36) instruction_list -> . instruction
    (37) instruction_list -> . instruction_list instruction
    (35) block_end -> . RBRACKET
    (7) declaration -> . type declarator_list SEMICOLON
    (21) instruction -> . SEMICOLON
    (22) instruction -> . compound_instruction
    (23) instruction -> . expression_instruction
    (24) instruction -> . iteration_instruction
    (25) instruction -> . select_instruction
    (26) instruction -> . jump_instruction
    (8) type -> . INT
    (9) type -> . STRING
    (30) compound_instruction -> . block_start declaration_list instruction_list block_end
    (31) compound_instruction -> . block_start declaration_list block_end
    (32) compound_instruction -> . block_start instruction_list block_end
    (33) compound_instruction -> . block_start block_end
    (27) expression_instruction -> . expression SEMICOLON
    (28) expression_instruction -> . assignment SEMICOLON
    (41) iteration_instruction -> . WHILE LPARENS condition RPARENS instruction
    (42) iteration_instruction -> . DO instruction WHILE LPARENS condition RPARENS
    (43) iteration_instruction -> . FOR LPARENS assignment SEMICOLON condition SEMICOLON assignment RPARENS instruction
    (38) select_instruction -> . cond_instruction THEN instruction
    (39) select_instruction -> . cond_instruction THEN instruction ELSE instruction
    (44) jump_instruction -> . RETURN expression SEMICOLON
    (34) block_start -> . LBRACKET
    (52) expression -> . expression_additive
    (53) expression -> . SHIFTLEFT expression_additive
    (54) expression -> . SHIFTRIGHT expression_additive
    (29) assignment -> . IDENT ASSIGNMENT expression
    (40) cond_instruction -> . IF LPARENS condition RPARENS
    (55) expression_additive -> . expression_multiplicative
    (56) expression_additive -> . expression_additive ADD expression_multiplicative
    (57) expression_additive -> . expression_additive SUBTRACT expression_multiplicative
    (58) expression_multiplicative -> . unary_expression
    (59) expression_multiplicative -> . expression_multiplicative MULTIPLY unary_expression
    (60) expression_multiplicative -> . expression_multiplicative DIVIDE unary_expression
    (61) expression_multiplicative -> . expression_multiplicative MODULO unary_expression
    (62) unary_expression -> . postfix_expression
    (63) unary_expression -> . SUBTRACT unary_expression
    (64) postfix_expression -> . primary_expression
    (65) postfix_expression -> . IDENT LPARENS argument_expression_list RPARENS
    (66) postfix_expression -> . IDENT LPARENS RPARENS
    (69) primary_expression -> . IDENT
    (70) primary_expression -> . CONST_INT
    (71) primary_expression -> . CONST_STRING
    (72) primary_expression -> . LPARENS expression RPARENS

    RBRACKET        shift and go to state 30
    SEMICOLON       shift and go to state 29
    INT             shift and go to state 7
    STRING          shift and go to state 6
    WHILE           shift and go to state 54
    DO              shift and go to state 38
    FOR             shift and go to state 56
    RETURN          shift and go to state 51
    LBRACKET        shift and go to state 22
    SHIFTLEFT       shift and go to state 40
    SHIFTRIGHT      shift and go to state 36
    IDENT           shift and go to state 49
    IF              shift and go to state 45
    SUBTRACT        shift and go to state 33
    CONST_INT       shift and go to state 43
    CONST_STRING    shift and go to state 28
    LPARENS         shift and go to state 47

    expression_instruction         shift and go to state 42
    select_instruction             shift and go to state 27
    compound_instruction           shift and go to state 44
    expression                     shift and go to state 31
    expression_multiplicative      shift and go to state 46
    postfix_expression             shift and go to state 48
    assignment                     shift and go to state 32
    type                           shift and go to state 10
    block_start                    shift and go to state 20
    declaration                    shift and go to state 25
    primary_expression             shift and go to state 34
    unary_expression               shift and go to state 50
    cond_instruction               shift and go to state 35
    expression_additive            shift and go to state 52
    iteration_instruction          shift and go to state 53
    jump_instruction               shift and go to state 37
    block_end                      shift and go to state 86
    instruction                    shift and go to state 39
    instruction_list               shift and go to state 85

state 58

    (11) declarator_list -> declaration_list COMMA declarator .

    SEMICOLON       reduce using rule 11 (declarator_list -> declaration_list COMMA declarator .)


state 59

    (18) parameter_list -> parameter_declaration .

    RPARENS         reduce using rule 18 (parameter_list -> parameter_declaration .)
    COMMA           reduce using rule 18 (parameter_list -> parameter_declaration .)


state 60

    (16) function_declarator -> IDENT LPARENS RPARENS .

    LBRACKET        reduce using rule 16 (function_declarator -> IDENT LPARENS RPARENS .)
    SEMICOLON       reduce using rule 16 (function_declarator -> IDENT LPARENS RPARENS .)


state 61

    (17) function_declarator -> IDENT LPARENS parameter_list . RPARENS
    (19) parameter_list -> parameter_list . COMMA parameter_declaration

    RPARENS         shift and go to state 88
    COMMA           shift and go to state 87


state 62

    (20) parameter_declaration -> type . IDENT

    IDENT           shift and go to state 89


state 63

    (27) expression_instruction -> expression SEMICOLON .

    ELSE            reduce using rule 27 (expression_instruction -> expression SEMICOLON .)
    RBRACKET        reduce using rule 27 (expression_instruction -> expression SEMICOLON .)
    SEMICOLON       reduce using rule 27 (expression_instruction -> expression SEMICOLON .)
    WHILE           reduce using rule 27 (expression_instruction -> expression SEMICOLON .)
    DO              reduce using rule 27 (expression_instruction -> expression SEMICOLON .)
    FOR             reduce using rule 27 (expression_instruction -> expression SEMICOLON .)
    RETURN          reduce using rule 27 (expression_instruction -> expression SEMICOLON .)
    LBRACKET        reduce using rule 27 (expression_instruction -> expression SEMICOLON .)
    SHIFTLEFT       reduce using rule 27 (expression_instruction -> expression SEMICOLON .)
    SHIFTRIGHT      reduce using rule 27 (expression_instruction -> expression SEMICOLON .)
    IDENT           reduce using rule 27 (expression_instruction -> expression SEMICOLON .)
    IF              reduce using rule 27 (expression_instruction -> expression SEMICOLON .)
    SUBTRACT        reduce using rule 27 (expression_instruction -> expression SEMICOLON .)
    CONST_INT       reduce using rule 27 (expression_instruction -> expression SEMICOLON .)
    CONST_STRING    reduce using rule 27 (expression_instruction -> expression SEMICOLON .)
    LPARENS         reduce using rule 27 (expression_instruction -> expression SEMICOLON .)


state 64

    (28) expression_instruction -> assignment SEMICOLON .

    ELSE            reduce using rule 28 (expression_instruction -> assignment SEMICOLON .)
    RBRACKET        reduce using rule 28 (expression_instruction -> assignment SEMICOLON .)
    SEMICOLON       reduce using rule 28 (expression_instruction -> assignment SEMICOLON .)
    WHILE           reduce using rule 28 (expression_instruction -> assignment SEMICOLON .)
    DO              reduce using rule 28 (expression_instruction -> assignment SEMICOLON .)
    FOR             reduce using rule 28 (expression_instruction -> assignment SEMICOLON .)
    RETURN          reduce using rule 28 (expression_instruction -> assignment SEMICOLON .)
    LBRACKET        reduce using rule 28 (expression_instruction -> assignment SEMICOLON .)
    SHIFTLEFT       reduce using rule 28 (expression_instruction -> assignment SEMICOLON .)
    SHIFTRIGHT      reduce using rule 28 (expression_instruction -> assignment SEMICOLON .)
    IDENT           reduce using rule 28 (expression_instruction -> assignment SEMICOLON .)
    IF              reduce using rule 28 (expression_instruction -> assignment SEMICOLON .)
    SUBTRACT        reduce using rule 28 (expression_instruction -> assignment SEMICOLON .)
    CONST_INT       reduce using rule 28 (expression_instruction -> assignment SEMICOLON .)
    CONST_STRING    reduce using rule 28 (expression_instruction -> assignment SEMICOLON .)
    LPARENS         reduce using rule 28 (expression_instruction -> assignment SEMICOLON .)


state 65

    (63) unary_expression -> SUBTRACT unary_expression .

    MULTIPLY        reduce using rule 63 (unary_expression -> SUBTRACT unary_expression .)
    DIVIDE          reduce using rule 63 (unary_expression -> SUBTRACT unary_expression .)
    MODULO          reduce using rule 63 (unary_expression -> SUBTRACT unary_expression .)
    ADD             reduce using rule 63 (unary_expression -> SUBTRACT unary_expression .)
    SUBTRACT        reduce using rule 63 (unary_expression -> SUBTRACT unary_expression .)
    SEMICOLON       reduce using rule 63 (unary_expression -> SUBTRACT unary_expression .)
    RPARENS         reduce using rule 63 (unary_expression -> SUBTRACT unary_expression .)
    EQUAL           reduce using rule 63 (unary_expression -> SUBTRACT unary_expression .)
    NOTEQUAL        reduce using rule 63 (unary_expression -> SUBTRACT unary_expression .)
    LESS            reduce using rule 63 (unary_expression -> SUBTRACT unary_expression .)
    GREATER         reduce using rule 63 (unary_expression -> SUBTRACT unary_expression .)
    LESSEQUAL       reduce using rule 63 (unary_expression -> SUBTRACT unary_expression .)
    GREATEREQUAL    reduce using rule 63 (unary_expression -> SUBTRACT unary_expression .)
    COMMA           reduce using rule 63 (unary_expression -> SUBTRACT unary_expression .)


state 66

    (65) postfix_expression -> IDENT . LPARENS argument_expression_list RPARENS
    (66) postfix_expression -> IDENT . LPARENS RPARENS
    (69) primary_expression -> IDENT .

    LPARENS         shift and go to state 78
    MULTIPLY        reduce using rule 69 (primary_expression -> IDENT .)
    DIVIDE          reduce using rule 69 (primary_expression -> IDENT .)
    MODULO          reduce using rule 69 (primary_expression -> IDENT .)
    ADD             reduce using rule 69 (primary_expression -> IDENT .)
    SUBTRACT        reduce using rule 69 (primary_expression -> IDENT .)
    RPARENS         reduce using rule 69 (primary_expression -> IDENT .)
    SEMICOLON       reduce using rule 69 (primary_expression -> IDENT .)
    COMMA           reduce using rule 69 (primary_expression -> IDENT .)
    EQUAL           reduce using rule 69 (primary_expression -> IDENT .)
    NOTEQUAL        reduce using rule 69 (primary_expression -> IDENT .)
    LESS            reduce using rule 69 (primary_expression -> IDENT .)
    GREATER         reduce using rule 69 (primary_expression -> IDENT .)
    LESSEQUAL       reduce using rule 69 (primary_expression -> IDENT .)
    GREATEREQUAL    reduce using rule 69 (primary_expression -> IDENT .)


state 67

    (38) select_instruction -> cond_instruction THEN . instruction
    (39) select_instruction -> cond_instruction THEN . instruction ELSE instruction
    (21) instruction -> . SEMICOLON
    (22) instruction -> . compound_instruction
    (23) instruction -> . expression_instruction
    (24) instruction -> . iteration_instruction
    (25) instruction -> . select_instruction
    (26) instruction -> . jump_instruction
    (30) compound_instruction -> . block_start declaration_list instruction_list block_end
    (31) compound_instruction -> . block_start declaration_list block_end
    (32) compound_instruction -> . block_start instruction_list block_end
    (33) compound_instruction -> . block_start block_end
    (27) expression_instruction -> . expression SEMICOLON
    (28) expression_instruction -> . assignment SEMICOLON
    (41) iteration_instruction -> . WHILE LPARENS condition RPARENS instruction
    (42) iteration_instruction -> . DO instruction WHILE LPARENS condition RPARENS
    (43) iteration_instruction -> . FOR LPARENS assignment SEMICOLON condition SEMICOLON assignment RPARENS instruction
    (38) select_instruction -> . cond_instruction THEN instruction
    (39) select_instruction -> . cond_instruction THEN instruction ELSE instruction
    (44) jump_instruction -> . RETURN expression SEMICOLON
    (34) block_start -> . LBRACKET
    (52) expression -> . expression_additive
    (53) expression -> . SHIFTLEFT expression_additive
    (54) expression -> . SHIFTRIGHT expression_additive
    (29) assignment -> . IDENT ASSIGNMENT expression
    (40) cond_instruction -> . IF LPARENS condition RPARENS
    (55) expression_additive -> . expression_multiplicative
    (56) expression_additive -> . expression_additive ADD expression_multiplicative
    (57) expression_additive -> . expression_additive SUBTRACT expression_multiplicative
    (58) expression_multiplicative -> . unary_expression
    (59) expression_multiplicative -> . expression_multiplicative MULTIPLY unary_expression
    (60) expression_multiplicative -> . expression_multiplicative DIVIDE unary_expression
    (61) expression_multiplicative -> . expression_multiplicative MODULO unary_expression
    (62) unary_expression -> . postfix_expression
    (63) unary_expression -> . SUBTRACT unary_expression
    (64) postfix_expression -> . primary_expression
    (65) postfix_expression -> . IDENT LPARENS argument_expression_list RPARENS
    (66) postfix_expression -> . IDENT LPARENS RPARENS
    (69) primary_expression -> . IDENT
    (70) primary_expression -> . CONST_INT
    (71) primary_expression -> . CONST_STRING
    (72) primary_expression -> . LPARENS expression RPARENS

    SEMICOLON       shift and go to state 29
    WHILE           shift and go to state 54
    DO              shift and go to state 38
    FOR             shift and go to state 56
    RETURN          shift and go to state 51
    LBRACKET        shift and go to state 22
    SHIFTLEFT       shift and go to state 40
    SHIFTRIGHT      shift and go to state 36
    IDENT           shift and go to state 49
    IF              shift and go to state 45
    SUBTRACT        shift and go to state 33
    CONST_INT       shift and go to state 43
    CONST_STRING    shift and go to state 28
    LPARENS         shift and go to state 47

    unary_expression               shift and go to state 50
    expression_instruction         shift and go to state 42
    block_start                    shift and go to state 20
    cond_instruction               shift and go to state 35
    select_instruction             shift and go to state 27
    primary_expression             shift and go to state 34
    compound_instruction           shift and go to state 44
    iteration_instruction          shift and go to state 53
    expression                     shift and go to state 31
    expression_multiplicative      shift and go to state 46
    jump_instruction               shift and go to state 37
    expression_additive            shift and go to state 52
    postfix_expression             shift and go to state 48
    instruction                    shift and go to state 90
    assignment                     shift and go to state 32

state 68

    (54) expression -> SHIFTRIGHT expression_additive .
    (56) expression_additive -> expression_additive . ADD expression_multiplicative
    (57) expression_additive -> expression_additive . SUBTRACT expression_multiplicative

    SEMICOLON       reduce using rule 54 (expression -> SHIFTRIGHT expression_additive .)
    RPARENS         reduce using rule 54 (expression -> SHIFTRIGHT expression_additive .)
    EQUAL           reduce using rule 54 (expression -> SHIFTRIGHT expression_additive .)
    NOTEQUAL        reduce using rule 54 (expression -> SHIFTRIGHT expression_additive .)
    LESS            reduce using rule 54 (expression -> SHIFTRIGHT expression_additive .)
    GREATER         reduce using rule 54 (expression -> SHIFTRIGHT expression_additive .)
    LESSEQUAL       reduce using rule 54 (expression -> SHIFTRIGHT expression_additive .)
    GREATEREQUAL    reduce using rule 54 (expression -> SHIFTRIGHT expression_additive .)
    COMMA           reduce using rule 54 (expression -> SHIFTRIGHT expression_additive .)
    ADD             shift and go to state 81
    SUBTRACT        shift and go to state 82


state 69

    (42) iteration_instruction -> DO instruction . WHILE LPARENS condition RPARENS

    WHILE           shift and go to state 91


state 70

    (53) expression -> SHIFTLEFT expression_additive .
    (56) expression_additive -> expression_additive . ADD expression_multiplicative
    (57) expression_additive -> expression_additive . SUBTRACT expression_multiplicative

    SEMICOLON       reduce using rule 53 (expression -> SHIFTLEFT expression_additive .)
    RPARENS         reduce using rule 53 (expression -> SHIFTLEFT expression_additive .)
    EQUAL           reduce using rule 53 (expression -> SHIFTLEFT expression_additive .)
    NOTEQUAL        reduce using rule 53 (expression -> SHIFTLEFT expression_additive .)
    LESS            reduce using rule 53 (expression -> SHIFTLEFT expression_additive .)
    GREATER         reduce using rule 53 (expression -> SHIFTLEFT expression_additive .)
    LESSEQUAL       reduce using rule 53 (expression -> SHIFTLEFT expression_additive .)
    GREATEREQUAL    reduce using rule 53 (expression -> SHIFTLEFT expression_additive .)
    COMMA           reduce using rule 53 (expression -> SHIFTLEFT expression_additive .)
    ADD             shift and go to state 81
    SUBTRACT        shift and go to state 82


state 71

    (32) compound_instruction -> block_start instruction_list block_end .

    EXTERN          reduce using rule 32 (compound_instruction -> block_start instruction_list block_end .)
    INT             reduce using rule 32 (compound_instruction -> block_start instruction_list block_end .)
    STRING          reduce using rule 32 (compound_instruction -> block_start instruction_list block_end .)
    $end            reduce using rule 32 (compound_instruction -> block_start instruction_list block_end .)
    ELSE            reduce using rule 32 (compound_instruction -> block_start instruction_list block_end .)
    RBRACKET        reduce using rule 32 (compound_instruction -> block_start instruction_list block_end .)
    SEMICOLON       reduce using rule 32 (compound_instruction -> block_start instruction_list block_end .)
    WHILE           reduce using rule 32 (compound_instruction -> block_start instruction_list block_end .)
    DO              reduce using rule 32 (compound_instruction -> block_start instruction_list block_end .)
    FOR             reduce using rule 32 (compound_instruction -> block_start instruction_list block_end .)
    RETURN          reduce using rule 32 (compound_instruction -> block_start instruction_list block_end .)
    LBRACKET        reduce using rule 32 (compound_instruction -> block_start instruction_list block_end .)
    SHIFTLEFT       reduce using rule 32 (compound_instruction -> block_start instruction_list block_end .)
    SHIFTRIGHT      reduce using rule 32 (compound_instruction -> block_start instruction_list block_end .)
    IDENT           reduce using rule 32 (compound_instruction -> block_start instruction_list block_end .)
    IF              reduce using rule 32 (compound_instruction -> block_start instruction_list block_end .)
    SUBTRACT        reduce using rule 32 (compound_instruction -> block_start instruction_list block_end .)
    CONST_INT       reduce using rule 32 (compound_instruction -> block_start instruction_list block_end .)
    CONST_STRING    reduce using rule 32 (compound_instruction -> block_start instruction_list block_end .)
    LPARENS         reduce using rule 32 (compound_instruction -> block_start instruction_list block_end .)


state 72

    (37) instruction_list -> instruction_list instruction .

    RBRACKET        reduce using rule 37 (instruction_list -> instruction_list instruction .)
    SEMICOLON       reduce using rule 37 (instruction_list -> instruction_list instruction .)
    WHILE           reduce using rule 37 (instruction_list -> instruction_list instruction .)
    DO              reduce using rule 37 (instruction_list -> instruction_list instruction .)
    FOR             reduce using rule 37 (instruction_list -> instruction_list instruction .)
    RETURN          reduce using rule 37 (instruction_list -> instruction_list instruction .)
    LBRACKET        reduce using rule 37 (instruction_list -> instruction_list instruction .)
    SHIFTLEFT       reduce using rule 37 (instruction_list -> instruction_list instruction .)
    SHIFTRIGHT      reduce using rule 37 (instruction_list -> instruction_list instruction .)
    IDENT           reduce using rule 37 (instruction_list -> instruction_list instruction .)
    IF              reduce using rule 37 (instruction_list -> instruction_list instruction .)
    SUBTRACT        reduce using rule 37 (instruction_list -> instruction_list instruction .)
    CONST_INT       reduce using rule 37 (instruction_list -> instruction_list instruction .)
    CONST_STRING    reduce using rule 37 (instruction_list -> instruction_list instruction .)
    LPARENS         reduce using rule 37 (instruction_list -> instruction_list instruction .)


state 73

    (40) cond_instruction -> IF LPARENS . condition RPARENS
    (45) condition -> . expression comparison_operator expression
    (52) expression -> . expression_additive
    (53) expression -> . SHIFTLEFT expression_additive
    (54) expression -> . SHIFTRIGHT expression_additive
    (55) expression_additive -> . expression_multiplicative
    (56) expression_additive -> . expression_additive ADD expression_multiplicative
    (57) expression_additive -> . expression_additive SUBTRACT expression_multiplicative
    (58) expression_multiplicative -> . unary_expression
    (59) expression_multiplicative -> . expression_multiplicative MULTIPLY unary_expression
    (60) expression_multiplicative -> . expression_multiplicative DIVIDE unary_expression
    (61) expression_multiplicative -> . expression_multiplicative MODULO unary_expression
    (62) unary_expression -> . postfix_expression
    (63) unary_expression -> . SUBTRACT unary_expression
    (64) postfix_expression -> . primary_expression
    (65) postfix_expression -> . IDENT LPARENS argument_expression_list RPARENS
    (66) postfix_expression -> . IDENT LPARENS RPARENS
    (69) primary_expression -> . IDENT
    (70) primary_expression -> . CONST_INT
    (71) primary_expression -> . CONST_STRING
    (72) primary_expression -> . LPARENS expression RPARENS

    SHIFTLEFT       shift and go to state 40
    SHIFTRIGHT      shift and go to state 36
    SUBTRACT        shift and go to state 33
    IDENT           shift and go to state 66
    CONST_INT       shift and go to state 43
    CONST_STRING    shift and go to state 28
    LPARENS         shift and go to state 47

    expression_multiplicative      shift and go to state 46
    primary_expression             shift and go to state 34
    unary_expression               shift and go to state 50
    condition                      shift and go to state 92
    expression_additive            shift and go to state 52
    postfix_expression             shift and go to state 48
    expression                     shift and go to state 93

state 74

    (61) expression_multiplicative -> expression_multiplicative MODULO . unary_expression
    (62) unary_expression -> . postfix_expression
    (63) unary_expression -> . SUBTRACT unary_expression
    (64) postfix_expression -> . primary_expression
    (65) postfix_expression -> . IDENT LPARENS argument_expression_list RPARENS
    (66) postfix_expression -> . IDENT LPARENS RPARENS
    (69) primary_expression -> . IDENT
    (70) primary_expression -> . CONST_INT
    (71) primary_expression -> . CONST_STRING
    (72) primary_expression -> . LPARENS expression RPARENS

    SUBTRACT        shift and go to state 33
    IDENT           shift and go to state 66
    CONST_INT       shift and go to state 43
    CONST_STRING    shift and go to state 28
    LPARENS         shift and go to state 47

    unary_expression               shift and go to state 94
    primary_expression             shift and go to state 34
    postfix_expression             shift and go to state 48

state 75

    (59) expression_multiplicative -> expression_multiplicative MULTIPLY . unary_expression
    (62) unary_expression -> . postfix_expression
    (63) unary_expression -> . SUBTRACT unary_expression
    (64) postfix_expression -> . primary_expression
    (65) postfix_expression -> . IDENT LPARENS argument_expression_list RPARENS
    (66) postfix_expression -> . IDENT LPARENS RPARENS
    (69) primary_expression -> . IDENT
    (70) primary_expression -> . CONST_INT
    (71) primary_expression -> . CONST_STRING
    (72) primary_expression -> . LPARENS expression RPARENS

    SUBTRACT        shift and go to state 33
    IDENT           shift and go to state 66
    CONST_INT       shift and go to state 43
    CONST_STRING    shift and go to state 28
    LPARENS         shift and go to state 47

    unary_expression               shift and go to state 95
    primary_expression             shift and go to state 34
    postfix_expression             shift and go to state 48

state 76

    (60) expression_multiplicative -> expression_multiplicative DIVIDE . unary_expression
    (62) unary_expression -> . postfix_expression
    (63) unary_expression -> . SUBTRACT unary_expression
    (64) postfix_expression -> . primary_expression
    (65) postfix_expression -> . IDENT LPARENS argument_expression_list RPARENS
    (66) postfix_expression -> . IDENT LPARENS RPARENS
    (69) primary_expression -> . IDENT
    (70) primary_expression -> . CONST_INT
    (71) primary_expression -> . CONST_STRING
    (72) primary_expression -> . LPARENS expression RPARENS

    SUBTRACT        shift and go to state 33
    IDENT           shift and go to state 66
    CONST_INT       shift and go to state 43
    CONST_STRING    shift and go to state 28
    LPARENS         shift and go to state 47

    unary_expression               shift and go to state 96
    primary_expression             shift and go to state 34
    postfix_expression             shift and go to state 48

state 77

    (72) primary_expression -> LPARENS expression . RPARENS

    RPARENS         shift and go to state 97


state 78

    (65) postfix_expression -> IDENT LPARENS . argument_expression_list RPARENS
    (66) postfix_expression -> IDENT LPARENS . RPARENS
    (67) argument_expression_list -> . expression
    (68) argument_expression_list -> . argument_expression_list COMMA expression
    (52) expression -> . expression_additive
    (53) expression -> . SHIFTLEFT expression_additive
    (54) expression -> . SHIFTRIGHT expression_additive
    (55) expression_additive -> . expression_multiplicative
    (56) expression_additive -> . expression_additive ADD expression_multiplicative
    (57) expression_additive -> . expression_additive SUBTRACT expression_multiplicative
    (58) expression_multiplicative -> . unary_expression
    (59) expression_multiplicative -> . expression_multiplicative MULTIPLY unary_expression
    (60) expression_multiplicative -> . expression_multiplicative DIVIDE unary_expression
    (61) expression_multiplicative -> . expression_multiplicative MODULO unary_expression
    (62) unary_expression -> . postfix_expression
    (63) unary_expression -> . SUBTRACT unary_expression
    (64) postfix_expression -> . primary_expression
    (65) postfix_expression -> . IDENT LPARENS argument_expression_list RPARENS
    (66) postfix_expression -> . IDENT LPARENS RPARENS
    (69) primary_expression -> . IDENT
    (70) primary_expression -> . CONST_INT
    (71) primary_expression -> . CONST_STRING
    (72) primary_expression -> . LPARENS expression RPARENS

    RPARENS         shift and go to state 99
    SHIFTLEFT       shift and go to state 40
    SHIFTRIGHT      shift and go to state 36
    SUBTRACT        shift and go to state 33
    IDENT           shift and go to state 66
    CONST_INT       shift and go to state 43
    CONST_STRING    shift and go to state 28
    LPARENS         shift and go to state 47

    expression_multiplicative      shift and go to state 46
    primary_expression             shift and go to state 34
    unary_expression               shift and go to state 50
    expression_additive            shift and go to state 52
    argument_expression_list       shift and go to state 100
    postfix_expression             shift and go to state 48
    expression                     shift and go to state 98

state 79

    (29) assignment -> IDENT ASSIGNMENT . expression
    (52) expression -> . expression_additive
    (53) expression -> . SHIFTLEFT expression_additive
    (54) expression -> . SHIFTRIGHT expression_additive
    (55) expression_additive -> . expression_multiplicative
    (56) expression_additive -> . expression_additive ADD expression_multiplicative
    (57) expression_additive -> . expression_additive SUBTRACT expression_multiplicative
    (58) expression_multiplicative -> . unary_expression
    (59) expression_multiplicative -> . expression_multiplicative MULTIPLY unary_expression
    (60) expression_multiplicative -> . expression_multiplicative DIVIDE unary_expression
    (61) expression_multiplicative -> . expression_multiplicative MODULO unary_expression
    (62) unary_expression -> . postfix_expression
    (63) unary_expression -> . SUBTRACT unary_expression
    (64) postfix_expression -> . primary_expression
    (65) postfix_expression -> . IDENT LPARENS argument_expression_list RPARENS
    (66) postfix_expression -> . IDENT LPARENS RPARENS
    (69) primary_expression -> . IDENT
    (70) primary_expression -> . CONST_INT
    (71) primary_expression -> . CONST_STRING
    (72) primary_expression -> . LPARENS expression RPARENS

    SHIFTLEFT       shift and go to state 40
    SHIFTRIGHT      shift and go to state 36
    SUBTRACT        shift and go to state 33
    IDENT           shift and go to state 66
    CONST_INT       shift and go to state 43
    CONST_STRING    shift and go to state 28
    LPARENS         shift and go to state 47

    expression_multiplicative      shift and go to state 46
    primary_expression             shift and go to state 34
    unary_expression               shift and go to state 50
    expression_additive            shift and go to state 52
    postfix_expression             shift and go to state 48
    expression                     shift and go to state 101

state 80

    (44) jump_instruction -> RETURN expression . SEMICOLON

    SEMICOLON       shift and go to state 102


state 81

    (56) expression_additive -> expression_additive ADD . expression_multiplicative
    (58) expression_multiplicative -> . unary_expression
    (59) expression_multiplicative -> . expression_multiplicative MULTIPLY unary_expression
    (60) expression_multiplicative -> . expression_multiplicative DIVIDE unary_expression
    (61) expression_multiplicative -> . expression_multiplicative MODULO unary_expression
    (62) unary_expression -> . postfix_expression
    (63) unary_expression -> . SUBTRACT unary_expression
    (64) postfix_expression -> . primary_expression
    (65) postfix_expression -> . IDENT LPARENS argument_expression_list RPARENS
    (66) postfix_expression -> . IDENT LPARENS RPARENS
    (69) primary_expression -> . IDENT
    (70) primary_expression -> . CONST_INT
    (71) primary_expression -> . CONST_STRING
    (72) primary_expression -> . LPARENS expression RPARENS

    SUBTRACT        shift and go to state 33
    IDENT           shift and go to state 66
    CONST_INT       shift and go to state 43
    CONST_STRING    shift and go to state 28
    LPARENS         shift and go to state 47

    expression_multiplicative      shift and go to state 103
    unary_expression               shift and go to state 50
    primary_expression             shift and go to state 34
    postfix_expression             shift and go to state 48

state 82

    (57) expression_additive -> expression_additive SUBTRACT . expression_multiplicative
    (58) expression_multiplicative -> . unary_expression
    (59) expression_multiplicative -> . expression_multiplicative MULTIPLY unary_expression
    (60) expression_multiplicative -> . expression_multiplicative DIVIDE unary_expression
    (61) expression_multiplicative -> . expression_multiplicative MODULO unary_expression
    (62) unary_expression -> . postfix_expression
    (63) unary_expression -> . SUBTRACT unary_expression
    (64) postfix_expression -> . primary_expression
    (65) postfix_expression -> . IDENT LPARENS argument_expression_list RPARENS
    (66) postfix_expression -> . IDENT LPARENS RPARENS
    (69) primary_expression -> . IDENT
    (70) primary_expression -> . CONST_INT
    (71) primary_expression -> . CONST_STRING
    (72) primary_expression -> . LPARENS expression RPARENS

    SUBTRACT        shift and go to state 33
    IDENT           shift and go to state 66
    CONST_INT       shift and go to state 43
    CONST_STRING    shift and go to state 28
    LPARENS         shift and go to state 47

    expression_multiplicative      shift and go to state 104
    unary_expression               shift and go to state 50
    primary_expression             shift and go to state 34
    postfix_expression             shift and go to state 48

state 83

    (41) iteration_instruction -> WHILE LPARENS . condition RPARENS instruction
    (45) condition -> . expression comparison_operator expression
    (52) expression -> . expression_additive
    (53) expression -> . SHIFTLEFT expression_additive
    (54) expression -> . SHIFTRIGHT expression_additive
    (55) expression_additive -> . expression_multiplicative
    (56) expression_additive -> . expression_additive ADD expression_multiplicative
    (57) expression_additive -> . expression_additive SUBTRACT expression_multiplicative
    (58) expression_multiplicative -> . unary_expression
    (59) expression_multiplicative -> . expression_multiplicative MULTIPLY unary_expression
    (60) expression_multiplicative -> . expression_multiplicative DIVIDE unary_expression
    (61) expression_multiplicative -> . expression_multiplicative MODULO unary_expression
    (62) unary_expression -> . postfix_expression
    (63) unary_expression -> . SUBTRACT unary_expression
    (64) postfix_expression -> . primary_expression
    (65) postfix_expression -> . IDENT LPARENS argument_expression_list RPARENS
    (66) postfix_expression -> . IDENT LPARENS RPARENS
    (69) primary_expression -> . IDENT
    (70) primary_expression -> . CONST_INT
    (71) primary_expression -> . CONST_STRING
    (72) primary_expression -> . LPARENS expression RPARENS

    SHIFTLEFT       shift and go to state 40
    SHIFTRIGHT      shift and go to state 36
    SUBTRACT        shift and go to state 33
    IDENT           shift and go to state 66
    CONST_INT       shift and go to state 43
    CONST_STRING    shift and go to state 28
    LPARENS         shift and go to state 47

    expression_multiplicative      shift and go to state 46
    primary_expression             shift and go to state 34
    unary_expression               shift and go to state 50
    condition                      shift and go to state 105
    expression_additive            shift and go to state 52
    postfix_expression             shift and go to state 48
    expression                     shift and go to state 93

state 84

    (43) iteration_instruction -> FOR LPARENS . assignment SEMICOLON condition SEMICOLON assignment RPARENS instruction
    (29) assignment -> . IDENT ASSIGNMENT expression

    IDENT           shift and go to state 106

    assignment                     shift and go to state 107

state 85

    (30) compound_instruction -> block_start declaration_list instruction_list . block_end
    (37) instruction_list -> instruction_list . instruction
    (35) block_end -> . RBRACKET
    (21) instruction -> . SEMICOLON
    (22) instruction -> . compound_instruction
    (23) instruction -> . expression_instruction
    (24) instruction -> . iteration_instruction
    (25) instruction -> . select_instruction
    (26) instruction -> . jump_instruction
    (30) compound_instruction -> . block_start declaration_list instruction_list block_end
    (31) compound_instruction -> . block_start declaration_list block_end
    (32) compound_instruction -> . block_start instruction_list block_end
    (33) compound_instruction -> . block_start block_end
    (27) expression_instruction -> . expression SEMICOLON
    (28) expression_instruction -> . assignment SEMICOLON
    (41) iteration_instruction -> . WHILE LPARENS condition RPARENS instruction
    (42) iteration_instruction -> . DO instruction WHILE LPARENS condition RPARENS
    (43) iteration_instruction -> . FOR LPARENS assignment SEMICOLON condition SEMICOLON assignment RPARENS instruction
    (38) select_instruction -> . cond_instruction THEN instruction
    (39) select_instruction -> . cond_instruction THEN instruction ELSE instruction
    (44) jump_instruction -> . RETURN expression SEMICOLON
    (34) block_start -> . LBRACKET
    (52) expression -> . expression_additive
    (53) expression -> . SHIFTLEFT expression_additive
    (54) expression -> . SHIFTRIGHT expression_additive
    (29) assignment -> . IDENT ASSIGNMENT expression
    (40) cond_instruction -> . IF LPARENS condition RPARENS
    (55) expression_additive -> . expression_multiplicative
    (56) expression_additive -> . expression_additive ADD expression_multiplicative
    (57) expression_additive -> . expression_additive SUBTRACT expression_multiplicative
    (58) expression_multiplicative -> . unary_expression
    (59) expression_multiplicative -> . expression_multiplicative MULTIPLY unary_expression
    (60) expression_multiplicative -> . expression_multiplicative DIVIDE unary_expression
    (61) expression_multiplicative -> . expression_multiplicative MODULO unary_expression
    (62) unary_expression -> . postfix_expression
    (63) unary_expression -> . SUBTRACT unary_expression
    (64) postfix_expression -> . primary_expression
    (65) postfix_expression -> . IDENT LPARENS argument_expression_list RPARENS
    (66) postfix_expression -> . IDENT LPARENS RPARENS
    (69) primary_expression -> . IDENT
    (70) primary_expression -> . CONST_INT
    (71) primary_expression -> . CONST_STRING
    (72) primary_expression -> . LPARENS expression RPARENS

    RBRACKET        shift and go to state 30
    SEMICOLON       shift and go to state 29
    WHILE           shift and go to state 54
    DO              shift and go to state 38
    FOR             shift and go to state 56
    RETURN          shift and go to state 51
    LBRACKET        shift and go to state 22
    SHIFTLEFT       shift and go to state 40
    SHIFTRIGHT      shift and go to state 36
    IDENT           shift and go to state 49
    IF              shift and go to state 45
    SUBTRACT        shift and go to state 33
    CONST_INT       shift and go to state 43
    CONST_STRING    shift and go to state 28
    LPARENS         shift and go to state 47

    unary_expression               shift and go to state 50
    expression_instruction         shift and go to state 42
    block_start                    shift and go to state 20
    cond_instruction               shift and go to state 35
    select_instruction             shift and go to state 27
    primary_expression             shift and go to state 34
    compound_instruction           shift and go to state 44
    iteration_instruction          shift and go to state 53
    expression                     shift and go to state 31
    expression_multiplicative      shift and go to state 46
    jump_instruction               shift and go to state 37
    expression_additive            shift and go to state 52
    block_end                      shift and go to state 108
    postfix_expression             shift and go to state 48
    instruction                    shift and go to state 72
    assignment                     shift and go to state 32

state 86

    (31) compound_instruction -> block_start declaration_list block_end .

    EXTERN          reduce using rule 31 (compound_instruction -> block_start declaration_list block_end .)
    INT             reduce using rule 31 (compound_instruction -> block_start declaration_list block_end .)
    STRING          reduce using rule 31 (compound_instruction -> block_start declaration_list block_end .)
    $end            reduce using rule 31 (compound_instruction -> block_start declaration_list block_end .)
    ELSE            reduce using rule 31 (compound_instruction -> block_start declaration_list block_end .)
    RBRACKET        reduce using rule 31 (compound_instruction -> block_start declaration_list block_end .)
    SEMICOLON       reduce using rule 31 (compound_instruction -> block_start declaration_list block_end .)
    WHILE           reduce using rule 31 (compound_instruction -> block_start declaration_list block_end .)
    DO              reduce using rule 31 (compound_instruction -> block_start declaration_list block_end .)
    FOR             reduce using rule 31 (compound_instruction -> block_start declaration_list block_end .)
    RETURN          reduce using rule 31 (compound_instruction -> block_start declaration_list block_end .)
    LBRACKET        reduce using rule 31 (compound_instruction -> block_start declaration_list block_end .)
    SHIFTLEFT       reduce using rule 31 (compound_instruction -> block_start declaration_list block_end .)
    SHIFTRIGHT      reduce using rule 31 (compound_instruction -> block_start declaration_list block_end .)
    IDENT           reduce using rule 31 (compound_instruction -> block_start declaration_list block_end .)
    IF              reduce using rule 31 (compound_instruction -> block_start declaration_list block_end .)
    SUBTRACT        reduce using rule 31 (compound_instruction -> block_start declaration_list block_end .)
    CONST_INT       reduce using rule 31 (compound_instruction -> block_start declaration_list block_end .)
    CONST_STRING    reduce using rule 31 (compound_instruction -> block_start declaration_list block_end .)
    LPARENS         reduce using rule 31 (compound_instruction -> block_start declaration_list block_end .)


state 87

    (19) parameter_list -> parameter_list COMMA . parameter_declaration
    (20) parameter_declaration -> . type IDENT
    (8) type -> . INT
    (9) type -> . STRING

    INT             shift and go to state 7
    STRING          shift and go to state 6

    type                           shift and go to state 62
    parameter_declaration          shift and go to state 109

state 88

    (17) function_declarator -> IDENT LPARENS parameter_list RPARENS .

    LBRACKET        reduce using rule 17 (function_declarator -> IDENT LPARENS parameter_list RPARENS .)
    SEMICOLON       reduce using rule 17 (function_declarator -> IDENT LPARENS parameter_list RPARENS .)


state 89

    (20) parameter_declaration -> type IDENT .

    RPARENS         reduce using rule 20 (parameter_declaration -> type IDENT .)
    COMMA           reduce using rule 20 (parameter_declaration -> type IDENT .)


state 90

    (38) select_instruction -> cond_instruction THEN instruction .
    (39) select_instruction -> cond_instruction THEN instruction . ELSE instruction

    RBRACKET        reduce using rule 38 (select_instruction -> cond_instruction THEN instruction .)
    SEMICOLON       reduce using rule 38 (select_instruction -> cond_instruction THEN instruction .)
    WHILE           reduce using rule 38 (select_instruction -> cond_instruction THEN instruction .)
    DO              reduce using rule 38 (select_instruction -> cond_instruction THEN instruction .)
    FOR             reduce using rule 38 (select_instruction -> cond_instruction THEN instruction .)
    RETURN          reduce using rule 38 (select_instruction -> cond_instruction THEN instruction .)
    LBRACKET        reduce using rule 38 (select_instruction -> cond_instruction THEN instruction .)
    SHIFTLEFT       reduce using rule 38 (select_instruction -> cond_instruction THEN instruction .)
    SHIFTRIGHT      reduce using rule 38 (select_instruction -> cond_instruction THEN instruction .)
    IDENT           reduce using rule 38 (select_instruction -> cond_instruction THEN instruction .)
    IF              reduce using rule 38 (select_instruction -> cond_instruction THEN instruction .)
    SUBTRACT        reduce using rule 38 (select_instruction -> cond_instruction THEN instruction .)
    CONST_INT       reduce using rule 38 (select_instruction -> cond_instruction THEN instruction .)
    CONST_STRING    reduce using rule 38 (select_instruction -> cond_instruction THEN instruction .)
    LPARENS         reduce using rule 38 (select_instruction -> cond_instruction THEN instruction .)
    ELSE            shift and go to state 110

  ! ELSE            [ reduce using rule 38 (select_instruction -> cond_instruction THEN instruction .) ]


state 91

    (42) iteration_instruction -> DO instruction WHILE . LPARENS condition RPARENS

    LPARENS         shift and go to state 111


state 92

    (40) cond_instruction -> IF LPARENS condition . RPARENS

    RPARENS         shift and go to state 112


state 93

    (45) condition -> expression . comparison_operator expression
    (46) comparison_operator -> . EQUAL
    (47) comparison_operator -> . NOTEQUAL
    (48) comparison_operator -> . LESS
    (49) comparison_operator -> . GREATER
    (50) comparison_operator -> . LESSEQUAL
    (51) comparison_operator -> . GREATEREQUAL

    EQUAL           shift and go to state 114
    NOTEQUAL        shift and go to state 116
    LESS            shift and go to state 115
    GREATER         shift and go to state 113
    LESSEQUAL       shift and go to state 119
    GREATEREQUAL    shift and go to state 117

    comparison_operator            shift and go to state 118

state 94

    (61) expression_multiplicative -> expression_multiplicative MODULO unary_expression .

    MULTIPLY        reduce using rule 61 (expression_multiplicative -> expression_multiplicative MODULO unary_expression .)
    DIVIDE          reduce using rule 61 (expression_multiplicative -> expression_multiplicative MODULO unary_expression .)
    MODULO          reduce using rule 61 (expression_multiplicative -> expression_multiplicative MODULO unary_expression .)
    ADD             reduce using rule 61 (expression_multiplicative -> expression_multiplicative MODULO unary_expression .)
    SUBTRACT        reduce using rule 61 (expression_multiplicative -> expression_multiplicative MODULO unary_expression .)
    SEMICOLON       reduce using rule 61 (expression_multiplicative -> expression_multiplicative MODULO unary_expression .)
    EQUAL           reduce using rule 61 (expression_multiplicative -> expression_multiplicative MODULO unary_expression .)
    NOTEQUAL        reduce using rule 61 (expression_multiplicative -> expression_multiplicative MODULO unary_expression .)
    LESS            reduce using rule 61 (expression_multiplicative -> expression_multiplicative MODULO unary_expression .)
    GREATER         reduce using rule 61 (expression_multiplicative -> expression_multiplicative MODULO unary_expression .)
    LESSEQUAL       reduce using rule 61 (expression_multiplicative -> expression_multiplicative MODULO unary_expression .)
    GREATEREQUAL    reduce using rule 61 (expression_multiplicative -> expression_multiplicative MODULO unary_expression .)
    RPARENS         reduce using rule 61 (expression_multiplicative -> expression_multiplicative MODULO unary_expression .)
    COMMA           reduce using rule 61 (expression_multiplicative -> expression_multiplicative MODULO unary_expression .)


state 95

    (59) expression_multiplicative -> expression_multiplicative MULTIPLY unary_expression .

    MULTIPLY        reduce using rule 59 (expression_multiplicative -> expression_multiplicative MULTIPLY unary_expression .)
    DIVIDE          reduce using rule 59 (expression_multiplicative -> expression_multiplicative MULTIPLY unary_expression .)
    MODULO          reduce using rule 59 (expression_multiplicative -> expression_multiplicative MULTIPLY unary_expression .)
    ADD             reduce using rule 59 (expression_multiplicative -> expression_multiplicative MULTIPLY unary_expression .)
    SUBTRACT        reduce using rule 59 (expression_multiplicative -> expression_multiplicative MULTIPLY unary_expression .)
    SEMICOLON       reduce using rule 59 (expression_multiplicative -> expression_multiplicative MULTIPLY unary_expression .)
    EQUAL           reduce using rule 59 (expression_multiplicative -> expression_multiplicative MULTIPLY unary_expression .)
    NOTEQUAL        reduce using rule 59 (expression_multiplicative -> expression_multiplicative MULTIPLY unary_expression .)
    LESS            reduce using rule 59 (expression_multiplicative -> expression_multiplicative MULTIPLY unary_expression .)
    GREATER         reduce using rule 59 (expression_multiplicative -> expression_multiplicative MULTIPLY unary_expression .)
    LESSEQUAL       reduce using rule 59 (expression_multiplicative -> expression_multiplicative MULTIPLY unary_expression .)
    GREATEREQUAL    reduce using rule 59 (expression_multiplicative -> expression_multiplicative MULTIPLY unary_expression .)
    RPARENS         reduce using rule 59 (expression_multiplicative -> expression_multiplicative MULTIPLY unary_expression .)
    COMMA           reduce using rule 59 (expression_multiplicative -> expression_multiplicative MULTIPLY unary_expression .)


state 96

    (60) expression_multiplicative -> expression_multiplicative DIVIDE unary_expression .

    MULTIPLY        reduce using rule 60 (expression_multiplicative -> expression_multiplicative DIVIDE unary_expression .)
    DIVIDE          reduce using rule 60 (expression_multiplicative -> expression_multiplicative DIVIDE unary_expression .)
    MODULO          reduce using rule 60 (expression_multiplicative -> expression_multiplicative DIVIDE unary_expression .)
    ADD             reduce using rule 60 (expression_multiplicative -> expression_multiplicative DIVIDE unary_expression .)
    SUBTRACT        reduce using rule 60 (expression_multiplicative -> expression_multiplicative DIVIDE unary_expression .)
    SEMICOLON       reduce using rule 60 (expression_multiplicative -> expression_multiplicative DIVIDE unary_expression .)
    EQUAL           reduce using rule 60 (expression_multiplicative -> expression_multiplicative DIVIDE unary_expression .)
    NOTEQUAL        reduce using rule 60 (expression_multiplicative -> expression_multiplicative DIVIDE unary_expression .)
    LESS            reduce using rule 60 (expression_multiplicative -> expression_multiplicative DIVIDE unary_expression .)
    GREATER         reduce using rule 60 (expression_multiplicative -> expression_multiplicative DIVIDE unary_expression .)
    LESSEQUAL       reduce using rule 60 (expression_multiplicative -> expression_multiplicative DIVIDE unary_expression .)
    GREATEREQUAL    reduce using rule 60 (expression_multiplicative -> expression_multiplicative DIVIDE unary_expression .)
    RPARENS         reduce using rule 60 (expression_multiplicative -> expression_multiplicative DIVIDE unary_expression .)
    COMMA           reduce using rule 60 (expression_multiplicative -> expression_multiplicative DIVIDE unary_expression .)


state 97

    (72) primary_expression -> LPARENS expression RPARENS .

    MULTIPLY        reduce using rule 72 (primary_expression -> LPARENS expression RPARENS .)
    DIVIDE          reduce using rule 72 (primary_expression -> LPARENS expression RPARENS .)
    MODULO          reduce using rule 72 (primary_expression -> LPARENS expression RPARENS .)
    ADD             reduce using rule 72 (primary_expression -> LPARENS expression RPARENS .)
    SUBTRACT        reduce using rule 72 (primary_expression -> LPARENS expression RPARENS .)
    RPARENS         reduce using rule 72 (primary_expression -> LPARENS expression RPARENS .)
    SEMICOLON       reduce using rule 72 (primary_expression -> LPARENS expression RPARENS .)
    COMMA           reduce using rule 72 (primary_expression -> LPARENS expression RPARENS .)
    EQUAL           reduce using rule 72 (primary_expression -> LPARENS expression RPARENS .)
    NOTEQUAL        reduce using rule 72 (primary_expression -> LPARENS expression RPARENS .)
    LESS            reduce using rule 72 (primary_expression -> LPARENS expression RPARENS .)
    GREATER         reduce using rule 72 (primary_expression -> LPARENS expression RPARENS .)
    LESSEQUAL       reduce using rule 72 (primary_expression -> LPARENS expression RPARENS .)
    GREATEREQUAL    reduce using rule 72 (primary_expression -> LPARENS expression RPARENS .)


state 98

    (67) argument_expression_list -> expression .

    RPARENS         reduce using rule 67 (argument_expression_list -> expression .)
    COMMA           reduce using rule 67 (argument_expression_list -> expression .)


state 99

    (66) postfix_expression -> IDENT LPARENS RPARENS .

    MULTIPLY        reduce using rule 66 (postfix_expression -> IDENT LPARENS RPARENS .)
    DIVIDE          reduce using rule 66 (postfix_expression -> IDENT LPARENS RPARENS .)
    MODULO          reduce using rule 66 (postfix_expression -> IDENT LPARENS RPARENS .)
    ADD             reduce using rule 66 (postfix_expression -> IDENT LPARENS RPARENS .)
    SUBTRACT        reduce using rule 66 (postfix_expression -> IDENT LPARENS RPARENS .)
    RPARENS         reduce using rule 66 (postfix_expression -> IDENT LPARENS RPARENS .)
    SEMICOLON       reduce using rule 66 (postfix_expression -> IDENT LPARENS RPARENS .)
    EQUAL           reduce using rule 66 (postfix_expression -> IDENT LPARENS RPARENS .)
    NOTEQUAL        reduce using rule 66 (postfix_expression -> IDENT LPARENS RPARENS .)
    LESS            reduce using rule 66 (postfix_expression -> IDENT LPARENS RPARENS .)
    GREATER         reduce using rule 66 (postfix_expression -> IDENT LPARENS RPARENS .)
    LESSEQUAL       reduce using rule 66 (postfix_expression -> IDENT LPARENS RPARENS .)
    GREATEREQUAL    reduce using rule 66 (postfix_expression -> IDENT LPARENS RPARENS .)
    COMMA           reduce using rule 66 (postfix_expression -> IDENT LPARENS RPARENS .)


state 100

    (65) postfix_expression -> IDENT LPARENS argument_expression_list . RPARENS
    (68) argument_expression_list -> argument_expression_list . COMMA expression

    RPARENS         shift and go to state 121
    COMMA           shift and go to state 120


state 101

    (29) assignment -> IDENT ASSIGNMENT expression .

    SEMICOLON       reduce using rule 29 (assignment -> IDENT ASSIGNMENT expression .)
    RPARENS         reduce using rule 29 (assignment -> IDENT ASSIGNMENT expression .)


state 102

    (44) jump_instruction -> RETURN expression SEMICOLON .

    RBRACKET        reduce using rule 44 (jump_instruction -> RETURN expression SEMICOLON .)
    SEMICOLON       reduce using rule 44 (jump_instruction -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 44 (jump_instruction -> RETURN expression SEMICOLON .)
    DO              reduce using rule 44 (jump_instruction -> RETURN expression SEMICOLON .)
    FOR             reduce using rule 44 (jump_instruction -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 44 (jump_instruction -> RETURN expression SEMICOLON .)
    LBRACKET        reduce using rule 44 (jump_instruction -> RETURN expression SEMICOLON .)
    SHIFTLEFT       reduce using rule 44 (jump_instruction -> RETURN expression SEMICOLON .)
    SHIFTRIGHT      reduce using rule 44 (jump_instruction -> RETURN expression SEMICOLON .)
    IDENT           reduce using rule 44 (jump_instruction -> RETURN expression SEMICOLON .)
    IF              reduce using rule 44 (jump_instruction -> RETURN expression SEMICOLON .)
    SUBTRACT        reduce using rule 44 (jump_instruction -> RETURN expression SEMICOLON .)
    CONST_INT       reduce using rule 44 (jump_instruction -> RETURN expression SEMICOLON .)
    CONST_STRING    reduce using rule 44 (jump_instruction -> RETURN expression SEMICOLON .)
    LPARENS         reduce using rule 44 (jump_instruction -> RETURN expression SEMICOLON .)
    ELSE            reduce using rule 44 (jump_instruction -> RETURN expression SEMICOLON .)


state 103

    (56) expression_additive -> expression_additive ADD expression_multiplicative .
    (59) expression_multiplicative -> expression_multiplicative . MULTIPLY unary_expression
    (60) expression_multiplicative -> expression_multiplicative . DIVIDE unary_expression
    (61) expression_multiplicative -> expression_multiplicative . MODULO unary_expression

    ADD             reduce using rule 56 (expression_additive -> expression_additive ADD expression_multiplicative .)
    SUBTRACT        reduce using rule 56 (expression_additive -> expression_additive ADD expression_multiplicative .)
    EQUAL           reduce using rule 56 (expression_additive -> expression_additive ADD expression_multiplicative .)
    NOTEQUAL        reduce using rule 56 (expression_additive -> expression_additive ADD expression_multiplicative .)
    LESS            reduce using rule 56 (expression_additive -> expression_additive ADD expression_multiplicative .)
    GREATER         reduce using rule 56 (expression_additive -> expression_additive ADD expression_multiplicative .)
    LESSEQUAL       reduce using rule 56 (expression_additive -> expression_additive ADD expression_multiplicative .)
    GREATEREQUAL    reduce using rule 56 (expression_additive -> expression_additive ADD expression_multiplicative .)
    SEMICOLON       reduce using rule 56 (expression_additive -> expression_additive ADD expression_multiplicative .)
    RPARENS         reduce using rule 56 (expression_additive -> expression_additive ADD expression_multiplicative .)
    COMMA           reduce using rule 56 (expression_additive -> expression_additive ADD expression_multiplicative .)
    MULTIPLY        shift and go to state 75
    DIVIDE          shift and go to state 76
    MODULO          shift and go to state 74


state 104

    (57) expression_additive -> expression_additive SUBTRACT expression_multiplicative .
    (59) expression_multiplicative -> expression_multiplicative . MULTIPLY unary_expression
    (60) expression_multiplicative -> expression_multiplicative . DIVIDE unary_expression
    (61) expression_multiplicative -> expression_multiplicative . MODULO unary_expression

    ADD             reduce using rule 57 (expression_additive -> expression_additive SUBTRACT expression_multiplicative .)
    SUBTRACT        reduce using rule 57 (expression_additive -> expression_additive SUBTRACT expression_multiplicative .)
    EQUAL           reduce using rule 57 (expression_additive -> expression_additive SUBTRACT expression_multiplicative .)
    NOTEQUAL        reduce using rule 57 (expression_additive -> expression_additive SUBTRACT expression_multiplicative .)
    LESS            reduce using rule 57 (expression_additive -> expression_additive SUBTRACT expression_multiplicative .)
    GREATER         reduce using rule 57 (expression_additive -> expression_additive SUBTRACT expression_multiplicative .)
    LESSEQUAL       reduce using rule 57 (expression_additive -> expression_additive SUBTRACT expression_multiplicative .)
    GREATEREQUAL    reduce using rule 57 (expression_additive -> expression_additive SUBTRACT expression_multiplicative .)
    SEMICOLON       reduce using rule 57 (expression_additive -> expression_additive SUBTRACT expression_multiplicative .)
    RPARENS         reduce using rule 57 (expression_additive -> expression_additive SUBTRACT expression_multiplicative .)
    COMMA           reduce using rule 57 (expression_additive -> expression_additive SUBTRACT expression_multiplicative .)
    MULTIPLY        shift and go to state 75
    DIVIDE          shift and go to state 76
    MODULO          shift and go to state 74


state 105

    (41) iteration_instruction -> WHILE LPARENS condition . RPARENS instruction

    RPARENS         shift and go to state 122


state 106

    (29) assignment -> IDENT . ASSIGNMENT expression

    ASSIGNMENT      shift and go to state 79


state 107

    (43) iteration_instruction -> FOR LPARENS assignment . SEMICOLON condition SEMICOLON assignment RPARENS instruction

    SEMICOLON       shift and go to state 123


state 108

    (30) compound_instruction -> block_start declaration_list instruction_list block_end .

    EXTERN          reduce using rule 30 (compound_instruction -> block_start declaration_list instruction_list block_end .)
    INT             reduce using rule 30 (compound_instruction -> block_start declaration_list instruction_list block_end .)
    STRING          reduce using rule 30 (compound_instruction -> block_start declaration_list instruction_list block_end .)
    $end            reduce using rule 30 (compound_instruction -> block_start declaration_list instruction_list block_end .)
    ELSE            reduce using rule 30 (compound_instruction -> block_start declaration_list instruction_list block_end .)
    RBRACKET        reduce using rule 30 (compound_instruction -> block_start declaration_list instruction_list block_end .)
    SEMICOLON       reduce using rule 30 (compound_instruction -> block_start declaration_list instruction_list block_end .)
    WHILE           reduce using rule 30 (compound_instruction -> block_start declaration_list instruction_list block_end .)
    DO              reduce using rule 30 (compound_instruction -> block_start declaration_list instruction_list block_end .)
    FOR             reduce using rule 30 (compound_instruction -> block_start declaration_list instruction_list block_end .)
    RETURN          reduce using rule 30 (compound_instruction -> block_start declaration_list instruction_list block_end .)
    LBRACKET        reduce using rule 30 (compound_instruction -> block_start declaration_list instruction_list block_end .)
    SHIFTLEFT       reduce using rule 30 (compound_instruction -> block_start declaration_list instruction_list block_end .)
    SHIFTRIGHT      reduce using rule 30 (compound_instruction -> block_start declaration_list instruction_list block_end .)
    IDENT           reduce using rule 30 (compound_instruction -> block_start declaration_list instruction_list block_end .)
    IF              reduce using rule 30 (compound_instruction -> block_start declaration_list instruction_list block_end .)
    SUBTRACT        reduce using rule 30 (compound_instruction -> block_start declaration_list instruction_list block_end .)
    CONST_INT       reduce using rule 30 (compound_instruction -> block_start declaration_list instruction_list block_end .)
    CONST_STRING    reduce using rule 30 (compound_instruction -> block_start declaration_list instruction_list block_end .)
    LPARENS         reduce using rule 30 (compound_instruction -> block_start declaration_list instruction_list block_end .)


state 109

    (19) parameter_list -> parameter_list COMMA parameter_declaration .

    RPARENS         reduce using rule 19 (parameter_list -> parameter_list COMMA parameter_declaration .)
    COMMA           reduce using rule 19 (parameter_list -> parameter_list COMMA parameter_declaration .)


state 110

    (39) select_instruction -> cond_instruction THEN instruction ELSE . instruction
    (21) instruction -> . SEMICOLON
    (22) instruction -> . compound_instruction
    (23) instruction -> . expression_instruction
    (24) instruction -> . iteration_instruction
    (25) instruction -> . select_instruction
    (26) instruction -> . jump_instruction
    (30) compound_instruction -> . block_start declaration_list instruction_list block_end
    (31) compound_instruction -> . block_start declaration_list block_end
    (32) compound_instruction -> . block_start instruction_list block_end
    (33) compound_instruction -> . block_start block_end
    (27) expression_instruction -> . expression SEMICOLON
    (28) expression_instruction -> . assignment SEMICOLON
    (41) iteration_instruction -> . WHILE LPARENS condition RPARENS instruction
    (42) iteration_instruction -> . DO instruction WHILE LPARENS condition RPARENS
    (43) iteration_instruction -> . FOR LPARENS assignment SEMICOLON condition SEMICOLON assignment RPARENS instruction
    (38) select_instruction -> . cond_instruction THEN instruction
    (39) select_instruction -> . cond_instruction THEN instruction ELSE instruction
    (44) jump_instruction -> . RETURN expression SEMICOLON
    (34) block_start -> . LBRACKET
    (52) expression -> . expression_additive
    (53) expression -> . SHIFTLEFT expression_additive
    (54) expression -> . SHIFTRIGHT expression_additive
    (29) assignment -> . IDENT ASSIGNMENT expression
    (40) cond_instruction -> . IF LPARENS condition RPARENS
    (55) expression_additive -> . expression_multiplicative
    (56) expression_additive -> . expression_additive ADD expression_multiplicative
    (57) expression_additive -> . expression_additive SUBTRACT expression_multiplicative
    (58) expression_multiplicative -> . unary_expression
    (59) expression_multiplicative -> . expression_multiplicative MULTIPLY unary_expression
    (60) expression_multiplicative -> . expression_multiplicative DIVIDE unary_expression
    (61) expression_multiplicative -> . expression_multiplicative MODULO unary_expression
    (62) unary_expression -> . postfix_expression
    (63) unary_expression -> . SUBTRACT unary_expression
    (64) postfix_expression -> . primary_expression
    (65) postfix_expression -> . IDENT LPARENS argument_expression_list RPARENS
    (66) postfix_expression -> . IDENT LPARENS RPARENS
    (69) primary_expression -> . IDENT
    (70) primary_expression -> . CONST_INT
    (71) primary_expression -> . CONST_STRING
    (72) primary_expression -> . LPARENS expression RPARENS

    SEMICOLON       shift and go to state 29
    WHILE           shift and go to state 54
    DO              shift and go to state 38
    FOR             shift and go to state 56
    RETURN          shift and go to state 51
    LBRACKET        shift and go to state 22
    SHIFTLEFT       shift and go to state 40
    SHIFTRIGHT      shift and go to state 36
    IDENT           shift and go to state 49
    IF              shift and go to state 45
    SUBTRACT        shift and go to state 33
    CONST_INT       shift and go to state 43
    CONST_STRING    shift and go to state 28
    LPARENS         shift and go to state 47

    unary_expression               shift and go to state 50
    expression_instruction         shift and go to state 42
    block_start                    shift and go to state 20
    cond_instruction               shift and go to state 35
    select_instruction             shift and go to state 27
    primary_expression             shift and go to state 34
    compound_instruction           shift and go to state 44
    iteration_instruction          shift and go to state 53
    expression                     shift and go to state 31
    expression_multiplicative      shift and go to state 46
    jump_instruction               shift and go to state 37
    expression_additive            shift and go to state 52
    postfix_expression             shift and go to state 48
    instruction                    shift and go to state 124
    assignment                     shift and go to state 32

state 111

    (42) iteration_instruction -> DO instruction WHILE LPARENS . condition RPARENS
    (45) condition -> . expression comparison_operator expression
    (52) expression -> . expression_additive
    (53) expression -> . SHIFTLEFT expression_additive
    (54) expression -> . SHIFTRIGHT expression_additive
    (55) expression_additive -> . expression_multiplicative
    (56) expression_additive -> . expression_additive ADD expression_multiplicative
    (57) expression_additive -> . expression_additive SUBTRACT expression_multiplicative
    (58) expression_multiplicative -> . unary_expression
    (59) expression_multiplicative -> . expression_multiplicative MULTIPLY unary_expression
    (60) expression_multiplicative -> . expression_multiplicative DIVIDE unary_expression
    (61) expression_multiplicative -> . expression_multiplicative MODULO unary_expression
    (62) unary_expression -> . postfix_expression
    (63) unary_expression -> . SUBTRACT unary_expression
    (64) postfix_expression -> . primary_expression
    (65) postfix_expression -> . IDENT LPARENS argument_expression_list RPARENS
    (66) postfix_expression -> . IDENT LPARENS RPARENS
    (69) primary_expression -> . IDENT
    (70) primary_expression -> . CONST_INT
    (71) primary_expression -> . CONST_STRING
    (72) primary_expression -> . LPARENS expression RPARENS

    SHIFTLEFT       shift and go to state 40
    SHIFTRIGHT      shift and go to state 36
    SUBTRACT        shift and go to state 33
    IDENT           shift and go to state 66
    CONST_INT       shift and go to state 43
    CONST_STRING    shift and go to state 28
    LPARENS         shift and go to state 47

    expression_multiplicative      shift and go to state 46
    primary_expression             shift and go to state 34
    unary_expression               shift and go to state 50
    condition                      shift and go to state 125
    expression_additive            shift and go to state 52
    postfix_expression             shift and go to state 48
    expression                     shift and go to state 93

state 112

    (40) cond_instruction -> IF LPARENS condition RPARENS .

    THEN            reduce using rule 40 (cond_instruction -> IF LPARENS condition RPARENS .)


state 113

    (49) comparison_operator -> GREATER .

    SHIFTLEFT       reduce using rule 49 (comparison_operator -> GREATER .)
    SHIFTRIGHT      reduce using rule 49 (comparison_operator -> GREATER .)
    SUBTRACT        reduce using rule 49 (comparison_operator -> GREATER .)
    IDENT           reduce using rule 49 (comparison_operator -> GREATER .)
    CONST_INT       reduce using rule 49 (comparison_operator -> GREATER .)
    CONST_STRING    reduce using rule 49 (comparison_operator -> GREATER .)
    LPARENS         reduce using rule 49 (comparison_operator -> GREATER .)


state 114

    (46) comparison_operator -> EQUAL .

    SHIFTLEFT       reduce using rule 46 (comparison_operator -> EQUAL .)
    SHIFTRIGHT      reduce using rule 46 (comparison_operator -> EQUAL .)
    SUBTRACT        reduce using rule 46 (comparison_operator -> EQUAL .)
    IDENT           reduce using rule 46 (comparison_operator -> EQUAL .)
    CONST_INT       reduce using rule 46 (comparison_operator -> EQUAL .)
    CONST_STRING    reduce using rule 46 (comparison_operator -> EQUAL .)
    LPARENS         reduce using rule 46 (comparison_operator -> EQUAL .)


state 115

    (48) comparison_operator -> LESS .

    SHIFTLEFT       reduce using rule 48 (comparison_operator -> LESS .)
    SHIFTRIGHT      reduce using rule 48 (comparison_operator -> LESS .)
    SUBTRACT        reduce using rule 48 (comparison_operator -> LESS .)
    IDENT           reduce using rule 48 (comparison_operator -> LESS .)
    CONST_INT       reduce using rule 48 (comparison_operator -> LESS .)
    CONST_STRING    reduce using rule 48 (comparison_operator -> LESS .)
    LPARENS         reduce using rule 48 (comparison_operator -> LESS .)


state 116

    (47) comparison_operator -> NOTEQUAL .

    SHIFTLEFT       reduce using rule 47 (comparison_operator -> NOTEQUAL .)
    SHIFTRIGHT      reduce using rule 47 (comparison_operator -> NOTEQUAL .)
    SUBTRACT        reduce using rule 47 (comparison_operator -> NOTEQUAL .)
    IDENT           reduce using rule 47 (comparison_operator -> NOTEQUAL .)
    CONST_INT       reduce using rule 47 (comparison_operator -> NOTEQUAL .)
    CONST_STRING    reduce using rule 47 (comparison_operator -> NOTEQUAL .)
    LPARENS         reduce using rule 47 (comparison_operator -> NOTEQUAL .)


state 117

    (51) comparison_operator -> GREATEREQUAL .

    SHIFTLEFT       reduce using rule 51 (comparison_operator -> GREATEREQUAL .)
    SHIFTRIGHT      reduce using rule 51 (comparison_operator -> GREATEREQUAL .)
    SUBTRACT        reduce using rule 51 (comparison_operator -> GREATEREQUAL .)
    IDENT           reduce using rule 51 (comparison_operator -> GREATEREQUAL .)
    CONST_INT       reduce using rule 51 (comparison_operator -> GREATEREQUAL .)
    CONST_STRING    reduce using rule 51 (comparison_operator -> GREATEREQUAL .)
    LPARENS         reduce using rule 51 (comparison_operator -> GREATEREQUAL .)


state 118

    (45) condition -> expression comparison_operator . expression
    (52) expression -> . expression_additive
    (53) expression -> . SHIFTLEFT expression_additive
    (54) expression -> . SHIFTRIGHT expression_additive
    (55) expression_additive -> . expression_multiplicative
    (56) expression_additive -> . expression_additive ADD expression_multiplicative
    (57) expression_additive -> . expression_additive SUBTRACT expression_multiplicative
    (58) expression_multiplicative -> . unary_expression
    (59) expression_multiplicative -> . expression_multiplicative MULTIPLY unary_expression
    (60) expression_multiplicative -> . expression_multiplicative DIVIDE unary_expression
    (61) expression_multiplicative -> . expression_multiplicative MODULO unary_expression
    (62) unary_expression -> . postfix_expression
    (63) unary_expression -> . SUBTRACT unary_expression
    (64) postfix_expression -> . primary_expression
    (65) postfix_expression -> . IDENT LPARENS argument_expression_list RPARENS
    (66) postfix_expression -> . IDENT LPARENS RPARENS
    (69) primary_expression -> . IDENT
    (70) primary_expression -> . CONST_INT
    (71) primary_expression -> . CONST_STRING
    (72) primary_expression -> . LPARENS expression RPARENS

    SHIFTLEFT       shift and go to state 40
    SHIFTRIGHT      shift and go to state 36
    SUBTRACT        shift and go to state 33
    IDENT           shift and go to state 66
    CONST_INT       shift and go to state 43
    CONST_STRING    shift and go to state 28
    LPARENS         shift and go to state 47

    expression_multiplicative      shift and go to state 46
    primary_expression             shift and go to state 34
    unary_expression               shift and go to state 50
    expression_additive            shift and go to state 52
    postfix_expression             shift and go to state 48
    expression                     shift and go to state 126

state 119

    (50) comparison_operator -> LESSEQUAL .

    SHIFTLEFT       reduce using rule 50 (comparison_operator -> LESSEQUAL .)
    SHIFTRIGHT      reduce using rule 50 (comparison_operator -> LESSEQUAL .)
    SUBTRACT        reduce using rule 50 (comparison_operator -> LESSEQUAL .)
    IDENT           reduce using rule 50 (comparison_operator -> LESSEQUAL .)
    CONST_INT       reduce using rule 50 (comparison_operator -> LESSEQUAL .)
    CONST_STRING    reduce using rule 50 (comparison_operator -> LESSEQUAL .)
    LPARENS         reduce using rule 50 (comparison_operator -> LESSEQUAL .)


state 120

    (68) argument_expression_list -> argument_expression_list COMMA . expression
    (52) expression -> . expression_additive
    (53) expression -> . SHIFTLEFT expression_additive
    (54) expression -> . SHIFTRIGHT expression_additive
    (55) expression_additive -> . expression_multiplicative
    (56) expression_additive -> . expression_additive ADD expression_multiplicative
    (57) expression_additive -> . expression_additive SUBTRACT expression_multiplicative
    (58) expression_multiplicative -> . unary_expression
    (59) expression_multiplicative -> . expression_multiplicative MULTIPLY unary_expression
    (60) expression_multiplicative -> . expression_multiplicative DIVIDE unary_expression
    (61) expression_multiplicative -> . expression_multiplicative MODULO unary_expression
    (62) unary_expression -> . postfix_expression
    (63) unary_expression -> . SUBTRACT unary_expression
    (64) postfix_expression -> . primary_expression
    (65) postfix_expression -> . IDENT LPARENS argument_expression_list RPARENS
    (66) postfix_expression -> . IDENT LPARENS RPARENS
    (69) primary_expression -> . IDENT
    (70) primary_expression -> . CONST_INT
    (71) primary_expression -> . CONST_STRING
    (72) primary_expression -> . LPARENS expression RPARENS

    SHIFTLEFT       shift and go to state 40
    SHIFTRIGHT      shift and go to state 36
    SUBTRACT        shift and go to state 33
    IDENT           shift and go to state 66
    CONST_INT       shift and go to state 43
    CONST_STRING    shift and go to state 28
    LPARENS         shift and go to state 47

    expression_multiplicative      shift and go to state 46
    primary_expression             shift and go to state 34
    unary_expression               shift and go to state 50
    expression_additive            shift and go to state 52
    postfix_expression             shift and go to state 48
    expression                     shift and go to state 127

state 121

    (65) postfix_expression -> IDENT LPARENS argument_expression_list RPARENS .

    MULTIPLY        reduce using rule 65 (postfix_expression -> IDENT LPARENS argument_expression_list RPARENS .)
    DIVIDE          reduce using rule 65 (postfix_expression -> IDENT LPARENS argument_expression_list RPARENS .)
    MODULO          reduce using rule 65 (postfix_expression -> IDENT LPARENS argument_expression_list RPARENS .)
    ADD             reduce using rule 65 (postfix_expression -> IDENT LPARENS argument_expression_list RPARENS .)
    SUBTRACT        reduce using rule 65 (postfix_expression -> IDENT LPARENS argument_expression_list RPARENS .)
    RPARENS         reduce using rule 65 (postfix_expression -> IDENT LPARENS argument_expression_list RPARENS .)
    SEMICOLON       reduce using rule 65 (postfix_expression -> IDENT LPARENS argument_expression_list RPARENS .)
    EQUAL           reduce using rule 65 (postfix_expression -> IDENT LPARENS argument_expression_list RPARENS .)
    NOTEQUAL        reduce using rule 65 (postfix_expression -> IDENT LPARENS argument_expression_list RPARENS .)
    LESS            reduce using rule 65 (postfix_expression -> IDENT LPARENS argument_expression_list RPARENS .)
    GREATER         reduce using rule 65 (postfix_expression -> IDENT LPARENS argument_expression_list RPARENS .)
    LESSEQUAL       reduce using rule 65 (postfix_expression -> IDENT LPARENS argument_expression_list RPARENS .)
    GREATEREQUAL    reduce using rule 65 (postfix_expression -> IDENT LPARENS argument_expression_list RPARENS .)
    COMMA           reduce using rule 65 (postfix_expression -> IDENT LPARENS argument_expression_list RPARENS .)


state 122

    (41) iteration_instruction -> WHILE LPARENS condition RPARENS . instruction
    (21) instruction -> . SEMICOLON
    (22) instruction -> . compound_instruction
    (23) instruction -> . expression_instruction
    (24) instruction -> . iteration_instruction
    (25) instruction -> . select_instruction
    (26) instruction -> . jump_instruction
    (30) compound_instruction -> . block_start declaration_list instruction_list block_end
    (31) compound_instruction -> . block_start declaration_list block_end
    (32) compound_instruction -> . block_start instruction_list block_end
    (33) compound_instruction -> . block_start block_end
    (27) expression_instruction -> . expression SEMICOLON
    (28) expression_instruction -> . assignment SEMICOLON
    (41) iteration_instruction -> . WHILE LPARENS condition RPARENS instruction
    (42) iteration_instruction -> . DO instruction WHILE LPARENS condition RPARENS
    (43) iteration_instruction -> . FOR LPARENS assignment SEMICOLON condition SEMICOLON assignment RPARENS instruction
    (38) select_instruction -> . cond_instruction THEN instruction
    (39) select_instruction -> . cond_instruction THEN instruction ELSE instruction
    (44) jump_instruction -> . RETURN expression SEMICOLON
    (34) block_start -> . LBRACKET
    (52) expression -> . expression_additive
    (53) expression -> . SHIFTLEFT expression_additive
    (54) expression -> . SHIFTRIGHT expression_additive
    (29) assignment -> . IDENT ASSIGNMENT expression
    (40) cond_instruction -> . IF LPARENS condition RPARENS
    (55) expression_additive -> . expression_multiplicative
    (56) expression_additive -> . expression_additive ADD expression_multiplicative
    (57) expression_additive -> . expression_additive SUBTRACT expression_multiplicative
    (58) expression_multiplicative -> . unary_expression
    (59) expression_multiplicative -> . expression_multiplicative MULTIPLY unary_expression
    (60) expression_multiplicative -> . expression_multiplicative DIVIDE unary_expression
    (61) expression_multiplicative -> . expression_multiplicative MODULO unary_expression
    (62) unary_expression -> . postfix_expression
    (63) unary_expression -> . SUBTRACT unary_expression
    (64) postfix_expression -> . primary_expression
    (65) postfix_expression -> . IDENT LPARENS argument_expression_list RPARENS
    (66) postfix_expression -> . IDENT LPARENS RPARENS
    (69) primary_expression -> . IDENT
    (70) primary_expression -> . CONST_INT
    (71) primary_expression -> . CONST_STRING
    (72) primary_expression -> . LPARENS expression RPARENS

    SEMICOLON       shift and go to state 29
    WHILE           shift and go to state 54
    DO              shift and go to state 38
    FOR             shift and go to state 56
    RETURN          shift and go to state 51
    LBRACKET        shift and go to state 22
    SHIFTLEFT       shift and go to state 40
    SHIFTRIGHT      shift and go to state 36
    IDENT           shift and go to state 49
    IF              shift and go to state 45
    SUBTRACT        shift and go to state 33
    CONST_INT       shift and go to state 43
    CONST_STRING    shift and go to state 28
    LPARENS         shift and go to state 47

    unary_expression               shift and go to state 50
    expression_instruction         shift and go to state 42
    block_start                    shift and go to state 20
    cond_instruction               shift and go to state 35
    primary_expression             shift and go to state 34
    compound_instruction           shift and go to state 44
    select_instruction             shift and go to state 27
    iteration_instruction          shift and go to state 53
    expression                     shift and go to state 31
    expression_multiplicative      shift and go to state 46
    jump_instruction               shift and go to state 37
    expression_additive            shift and go to state 52
    postfix_expression             shift and go to state 48
    instruction                    shift and go to state 128
    assignment                     shift and go to state 32

state 123

    (43) iteration_instruction -> FOR LPARENS assignment SEMICOLON . condition SEMICOLON assignment RPARENS instruction
    (45) condition -> . expression comparison_operator expression
    (52) expression -> . expression_additive
    (53) expression -> . SHIFTLEFT expression_additive
    (54) expression -> . SHIFTRIGHT expression_additive
    (55) expression_additive -> . expression_multiplicative
    (56) expression_additive -> . expression_additive ADD expression_multiplicative
    (57) expression_additive -> . expression_additive SUBTRACT expression_multiplicative
    (58) expression_multiplicative -> . unary_expression
    (59) expression_multiplicative -> . expression_multiplicative MULTIPLY unary_expression
    (60) expression_multiplicative -> . expression_multiplicative DIVIDE unary_expression
    (61) expression_multiplicative -> . expression_multiplicative MODULO unary_expression
    (62) unary_expression -> . postfix_expression
    (63) unary_expression -> . SUBTRACT unary_expression
    (64) postfix_expression -> . primary_expression
    (65) postfix_expression -> . IDENT LPARENS argument_expression_list RPARENS
    (66) postfix_expression -> . IDENT LPARENS RPARENS
    (69) primary_expression -> . IDENT
    (70) primary_expression -> . CONST_INT
    (71) primary_expression -> . CONST_STRING
    (72) primary_expression -> . LPARENS expression RPARENS

    SHIFTLEFT       shift and go to state 40
    SHIFTRIGHT      shift and go to state 36
    SUBTRACT        shift and go to state 33
    IDENT           shift and go to state 66
    CONST_INT       shift and go to state 43
    CONST_STRING    shift and go to state 28
    LPARENS         shift and go to state 47

    expression_multiplicative      shift and go to state 46
    expression_additive            shift and go to state 52
    primary_expression             shift and go to state 34
    unary_expression               shift and go to state 50
    condition                      shift and go to state 129
    postfix_expression             shift and go to state 48
    expression                     shift and go to state 93

state 124

    (39) select_instruction -> cond_instruction THEN instruction ELSE instruction .

    ELSE            reduce using rule 39 (select_instruction -> cond_instruction THEN instruction ELSE instruction .)
    RBRACKET        reduce using rule 39 (select_instruction -> cond_instruction THEN instruction ELSE instruction .)
    SEMICOLON       reduce using rule 39 (select_instruction -> cond_instruction THEN instruction ELSE instruction .)
    WHILE           reduce using rule 39 (select_instruction -> cond_instruction THEN instruction ELSE instruction .)
    DO              reduce using rule 39 (select_instruction -> cond_instruction THEN instruction ELSE instruction .)
    FOR             reduce using rule 39 (select_instruction -> cond_instruction THEN instruction ELSE instruction .)
    RETURN          reduce using rule 39 (select_instruction -> cond_instruction THEN instruction ELSE instruction .)
    LBRACKET        reduce using rule 39 (select_instruction -> cond_instruction THEN instruction ELSE instruction .)
    SHIFTLEFT       reduce using rule 39 (select_instruction -> cond_instruction THEN instruction ELSE instruction .)
    SHIFTRIGHT      reduce using rule 39 (select_instruction -> cond_instruction THEN instruction ELSE instruction .)
    IDENT           reduce using rule 39 (select_instruction -> cond_instruction THEN instruction ELSE instruction .)
    IF              reduce using rule 39 (select_instruction -> cond_instruction THEN instruction ELSE instruction .)
    SUBTRACT        reduce using rule 39 (select_instruction -> cond_instruction THEN instruction ELSE instruction .)
    CONST_INT       reduce using rule 39 (select_instruction -> cond_instruction THEN instruction ELSE instruction .)
    CONST_STRING    reduce using rule 39 (select_instruction -> cond_instruction THEN instruction ELSE instruction .)
    LPARENS         reduce using rule 39 (select_instruction -> cond_instruction THEN instruction ELSE instruction .)


state 125

    (42) iteration_instruction -> DO instruction WHILE LPARENS condition . RPARENS

    RPARENS         shift and go to state 130


state 126

    (45) condition -> expression comparison_operator expression .

    RPARENS         reduce using rule 45 (condition -> expression comparison_operator expression .)
    SEMICOLON       reduce using rule 45 (condition -> expression comparison_operator expression .)


state 127

    (68) argument_expression_list -> argument_expression_list COMMA expression .

    RPARENS         reduce using rule 68 (argument_expression_list -> argument_expression_list COMMA expression .)
    COMMA           reduce using rule 68 (argument_expression_list -> argument_expression_list COMMA expression .)


state 128

    (41) iteration_instruction -> WHILE LPARENS condition RPARENS instruction .

    RBRACKET        reduce using rule 41 (iteration_instruction -> WHILE LPARENS condition RPARENS instruction .)
    SEMICOLON       reduce using rule 41 (iteration_instruction -> WHILE LPARENS condition RPARENS instruction .)
    WHILE           reduce using rule 41 (iteration_instruction -> WHILE LPARENS condition RPARENS instruction .)
    DO              reduce using rule 41 (iteration_instruction -> WHILE LPARENS condition RPARENS instruction .)
    FOR             reduce using rule 41 (iteration_instruction -> WHILE LPARENS condition RPARENS instruction .)
    RETURN          reduce using rule 41 (iteration_instruction -> WHILE LPARENS condition RPARENS instruction .)
    LBRACKET        reduce using rule 41 (iteration_instruction -> WHILE LPARENS condition RPARENS instruction .)
    SHIFTLEFT       reduce using rule 41 (iteration_instruction -> WHILE LPARENS condition RPARENS instruction .)
    SHIFTRIGHT      reduce using rule 41 (iteration_instruction -> WHILE LPARENS condition RPARENS instruction .)
    IDENT           reduce using rule 41 (iteration_instruction -> WHILE LPARENS condition RPARENS instruction .)
    IF              reduce using rule 41 (iteration_instruction -> WHILE LPARENS condition RPARENS instruction .)
    SUBTRACT        reduce using rule 41 (iteration_instruction -> WHILE LPARENS condition RPARENS instruction .)
    CONST_INT       reduce using rule 41 (iteration_instruction -> WHILE LPARENS condition RPARENS instruction .)
    CONST_STRING    reduce using rule 41 (iteration_instruction -> WHILE LPARENS condition RPARENS instruction .)
    LPARENS         reduce using rule 41 (iteration_instruction -> WHILE LPARENS condition RPARENS instruction .)
    ELSE            reduce using rule 41 (iteration_instruction -> WHILE LPARENS condition RPARENS instruction .)


state 129

    (43) iteration_instruction -> FOR LPARENS assignment SEMICOLON condition . SEMICOLON assignment RPARENS instruction

    SEMICOLON       shift and go to state 131


state 130

    (42) iteration_instruction -> DO instruction WHILE LPARENS condition RPARENS .

    RBRACKET        reduce using rule 42 (iteration_instruction -> DO instruction WHILE LPARENS condition RPARENS .)
    SEMICOLON       reduce using rule 42 (iteration_instruction -> DO instruction WHILE LPARENS condition RPARENS .)
    WHILE           reduce using rule 42 (iteration_instruction -> DO instruction WHILE LPARENS condition RPARENS .)
    DO              reduce using rule 42 (iteration_instruction -> DO instruction WHILE LPARENS condition RPARENS .)
    FOR             reduce using rule 42 (iteration_instruction -> DO instruction WHILE LPARENS condition RPARENS .)
    RETURN          reduce using rule 42 (iteration_instruction -> DO instruction WHILE LPARENS condition RPARENS .)
    LBRACKET        reduce using rule 42 (iteration_instruction -> DO instruction WHILE LPARENS condition RPARENS .)
    SHIFTLEFT       reduce using rule 42 (iteration_instruction -> DO instruction WHILE LPARENS condition RPARENS .)
    SHIFTRIGHT      reduce using rule 42 (iteration_instruction -> DO instruction WHILE LPARENS condition RPARENS .)
    IDENT           reduce using rule 42 (iteration_instruction -> DO instruction WHILE LPARENS condition RPARENS .)
    IF              reduce using rule 42 (iteration_instruction -> DO instruction WHILE LPARENS condition RPARENS .)
    SUBTRACT        reduce using rule 42 (iteration_instruction -> DO instruction WHILE LPARENS condition RPARENS .)
    CONST_INT       reduce using rule 42 (iteration_instruction -> DO instruction WHILE LPARENS condition RPARENS .)
    CONST_STRING    reduce using rule 42 (iteration_instruction -> DO instruction WHILE LPARENS condition RPARENS .)
    LPARENS         reduce using rule 42 (iteration_instruction -> DO instruction WHILE LPARENS condition RPARENS .)
    ELSE            reduce using rule 42 (iteration_instruction -> DO instruction WHILE LPARENS condition RPARENS .)


state 131

    (43) iteration_instruction -> FOR LPARENS assignment SEMICOLON condition SEMICOLON . assignment RPARENS instruction
    (29) assignment -> . IDENT ASSIGNMENT expression

    IDENT           shift and go to state 106

    assignment                     shift and go to state 132

state 132

    (43) iteration_instruction -> FOR LPARENS assignment SEMICOLON condition SEMICOLON assignment . RPARENS instruction

    RPARENS         shift and go to state 133


state 133

    (43) iteration_instruction -> FOR LPARENS assignment SEMICOLON condition SEMICOLON assignment RPARENS . instruction
    (21) instruction -> . SEMICOLON
    (22) instruction -> . compound_instruction
    (23) instruction -> . expression_instruction
    (24) instruction -> . iteration_instruction
    (25) instruction -> . select_instruction
    (26) instruction -> . jump_instruction
    (30) compound_instruction -> . block_start declaration_list instruction_list block_end
    (31) compound_instruction -> . block_start declaration_list block_end
    (32) compound_instruction -> . block_start instruction_list block_end
    (33) compound_instruction -> . block_start block_end
    (27) expression_instruction -> . expression SEMICOLON
    (28) expression_instruction -> . assignment SEMICOLON
    (41) iteration_instruction -> . WHILE LPARENS condition RPARENS instruction
    (42) iteration_instruction -> . DO instruction WHILE LPARENS condition RPARENS
    (43) iteration_instruction -> . FOR LPARENS assignment SEMICOLON condition SEMICOLON assignment RPARENS instruction
    (38) select_instruction -> . cond_instruction THEN instruction
    (39) select_instruction -> . cond_instruction THEN instruction ELSE instruction
    (44) jump_instruction -> . RETURN expression SEMICOLON
    (34) block_start -> . LBRACKET
    (52) expression -> . expression_additive
    (53) expression -> . SHIFTLEFT expression_additive
    (54) expression -> . SHIFTRIGHT expression_additive
    (29) assignment -> . IDENT ASSIGNMENT expression
    (40) cond_instruction -> . IF LPARENS condition RPARENS
    (55) expression_additive -> . expression_multiplicative
    (56) expression_additive -> . expression_additive ADD expression_multiplicative
    (57) expression_additive -> . expression_additive SUBTRACT expression_multiplicative
    (58) expression_multiplicative -> . unary_expression
    (59) expression_multiplicative -> . expression_multiplicative MULTIPLY unary_expression
    (60) expression_multiplicative -> . expression_multiplicative DIVIDE unary_expression
    (61) expression_multiplicative -> . expression_multiplicative MODULO unary_expression
    (62) unary_expression -> . postfix_expression
    (63) unary_expression -> . SUBTRACT unary_expression
    (64) postfix_expression -> . primary_expression
    (65) postfix_expression -> . IDENT LPARENS argument_expression_list RPARENS
    (66) postfix_expression -> . IDENT LPARENS RPARENS
    (69) primary_expression -> . IDENT
    (70) primary_expression -> . CONST_INT
    (71) primary_expression -> . CONST_STRING
    (72) primary_expression -> . LPARENS expression RPARENS

    SEMICOLON       shift and go to state 29
    WHILE           shift and go to state 54
    DO              shift and go to state 38
    FOR             shift and go to state 56
    RETURN          shift and go to state 51
    LBRACKET        shift and go to state 22
    SHIFTLEFT       shift and go to state 40
    SHIFTRIGHT      shift and go to state 36
    IDENT           shift and go to state 49
    IF              shift and go to state 45
    SUBTRACT        shift and go to state 33
    CONST_INT       shift and go to state 43
    CONST_STRING    shift and go to state 28
    LPARENS         shift and go to state 47

    unary_expression               shift and go to state 50
    expression_instruction         shift and go to state 42
    block_start                    shift and go to state 20
    cond_instruction               shift and go to state 35
    primary_expression             shift and go to state 34
    compound_instruction           shift and go to state 44
    select_instruction             shift and go to state 27
    iteration_instruction          shift and go to state 53
    expression                     shift and go to state 31
    expression_multiplicative      shift and go to state 46
    jump_instruction               shift and go to state 37
    expression_additive            shift and go to state 52
    postfix_expression             shift and go to state 48
    instruction                    shift and go to state 134
    assignment                     shift and go to state 32

state 134

    (43) iteration_instruction -> FOR LPARENS assignment SEMICOLON condition SEMICOLON assignment RPARENS instruction .

    RBRACKET        reduce using rule 43 (iteration_instruction -> FOR LPARENS assignment SEMICOLON condition SEMICOLON assignment RPARENS instruction .)
    SEMICOLON       reduce using rule 43 (iteration_instruction -> FOR LPARENS assignment SEMICOLON condition SEMICOLON assignment RPARENS instruction .)
    WHILE           reduce using rule 43 (iteration_instruction -> FOR LPARENS assignment SEMICOLON condition SEMICOLON assignment RPARENS instruction .)
    DO              reduce using rule 43 (iteration_instruction -> FOR LPARENS assignment SEMICOLON condition SEMICOLON assignment RPARENS instruction .)
    FOR             reduce using rule 43 (iteration_instruction -> FOR LPARENS assignment SEMICOLON condition SEMICOLON assignment RPARENS instruction .)
    RETURN          reduce using rule 43 (iteration_instruction -> FOR LPARENS assignment SEMICOLON condition SEMICOLON assignment RPARENS instruction .)
    LBRACKET        reduce using rule 43 (iteration_instruction -> FOR LPARENS assignment SEMICOLON condition SEMICOLON assignment RPARENS instruction .)
    SHIFTLEFT       reduce using rule 43 (iteration_instruction -> FOR LPARENS assignment SEMICOLON condition SEMICOLON assignment RPARENS instruction .)
    SHIFTRIGHT      reduce using rule 43 (iteration_instruction -> FOR LPARENS assignment SEMICOLON condition SEMICOLON assignment RPARENS instruction .)
    IDENT           reduce using rule 43 (iteration_instruction -> FOR LPARENS assignment SEMICOLON condition SEMICOLON assignment RPARENS instruction .)
    IF              reduce using rule 43 (iteration_instruction -> FOR LPARENS assignment SEMICOLON condition SEMICOLON assignment RPARENS instruction .)
    SUBTRACT        reduce using rule 43 (iteration_instruction -> FOR LPARENS assignment SEMICOLON condition SEMICOLON assignment RPARENS instruction .)
    CONST_INT       reduce using rule 43 (iteration_instruction -> FOR LPARENS assignment SEMICOLON condition SEMICOLON assignment RPARENS instruction .)
    CONST_STRING    reduce using rule 43 (iteration_instruction -> FOR LPARENS assignment SEMICOLON condition SEMICOLON assignment RPARENS instruction .)
    LPARENS         reduce using rule 43 (iteration_instruction -> FOR LPARENS assignment SEMICOLON condition SEMICOLON assignment RPARENS instruction .)
    ELSE            reduce using rule 43 (iteration_instruction -> FOR LPARENS assignment SEMICOLON condition SEMICOLON assignment RPARENS instruction .)

